

★　C　言語について

-------------------------------------------------------------

◎　ルール
　　1．C言語は大文字、小文字を区別する
　　2．文末は;
　　3．main関数が最初に動作する
　　4．コメント　/* */ 
　　5．改行は\n
　　6．使える数字は10進数、8進数、16進数
  　　　8進数　 ➡　先頭に　0　0152（10進数で106）
   　　 16進数　➡　先頭に　0x　0xFF（
　　7．変数宣言は関数の頭でしかできない
　　8．省略演算子（+=, -=, *=, /=, $=）、インクリメントデクリメント（++, --）は使える
　　9．型の種類（int　整数、double　実数、char　文字変数（1文字のみ）
　　10．if(条件式）文;
        ブロック文（複文）　{}
        }else if{}
        }else{}
　　11．等値演算子　==　!=
　　12．関係演算子　< > <= >=
　　13．論理演算子　&& || !
　　14．switch (条件式) {
          case 数値:
                実行分;
                break;
          case 数値:
                実行分;
                break;
          default:
                実行分;
                break;
         }
　　15．for文 for(初期化;条件式;更新）{}
  　　　　for(int i = 0; i <= 繰り返し回数; i++){}
　　16．while文
        初期化;
        while(条件式）{
          繰り返す文;
          更新;
        }
　　17．do{
          繰り返す文;
        }while(条件式);
　　18．プロトタイプ宣言
  　　　　関数の形を最初に宣言することで他のすべての関数からその関数を使えるようにすること。
      　　// プロトタイプ宣言
        　int sum(void);
         　void は引数を指定しないときに指定する。
         #include　もプロトタイプ宣言でstdio.hファイルの中の関数を使用していた。
　　　　　 // 仮引数宣言　➡　関数宣言に書かれた引数の型と名前のこと
      　　 int sum(int max);
           int sum(int);  でも可
          // 実引数　➡　関数に渡す数値のこと
           sum(50); // 呼び出し部
　　19．戻り値
   　　　関数の前の型宣言が戻り値の型を示している。
　　　　　関数の戻り値は変数に代入して使う。
　　20．ローカル変数
　　　　　実装例：関数内で宣言
     　　　int count;
  　　　　関数の中で宣言された変数。仮引数の変数も同様で関数が終わると捨てられ、再度関数が呼ばれた場合は新しく作られる。
　　　　　ローカル変数が有効なのは宣言された関数の中でのみである。
　　　　　グローバル変数よりもローカル変数が優先される。関数の独立性のため。
　　21．グローバル変数
　　　　　実装例：関数外で宣言
     　　　int count;
　　　　　関数外で宣言された変数。宣言されたソースファイル内のすべての関数から使用できる。
　　　　　自動的に0に初期化される。
　　22．スタティック変数（静的なローカル変数）
　　　　　実装例：関数内で宣言
　　　　　　static int count;
         ローカル変数とグローバル変数の特徴を併せ持つ。
　　　　　関数内で宣言する変数だが、プログラムが終了するまで残る変数で、初期化をしなくても自動的に0に初期化される。
　　　　　なお、初期化は最初に1回しかされない。
　　　　　関数が以前に呼び出された時の値を覚えておきたい場合に使用される。
　　　　　関数の呼び出し回数や検索を行う関数で以前に見つかった文字位置を記憶する場合などに利用できる。
　　23．配列
  　　　配列の宣言：　型名　配列名[要素数];
　　　　配列の初期化：　型名　配列名[要素数]　= {0番の数値, 1番の数値, ・・・};
　　　　配列の中身は配列の要素数よりも少ない場合、0が入る。
　　　　要素数を省略した場合は、要素の数だけ確保される。
　　　　配列の要素数を求めるのはsizeof演算子を使う。
　　　　// sizeof演算子の使い方
    　　sizeof(array) / sizeof(array[0])  配列の長さ（ビット）を配列の要素の長さ（ビット）で割ることで配列の要素数がわかる
    24．文字
    　　・文字コード
        　C言語では文字に対する番号が振られており、その番号に応じて文字を表現している。
        　ASCIIコードという規格では半角のアルファベットや記号が割り当てられている。
        　日本語を扱うのはJIS、shift-JIS、EUC、世界中の言語を扱うのはUnicodeなどが普及している。
        　文字コードは番号のため、文字に対して足し算を行うことができる。
        　例：
          　char c = 'A' + 9;
          　printf("%c\n", c);   // 結果：J

        ・文字列
        　文字変数の配列を作れば文字列になる。
        　文字列の最後に特別な値を記憶することで文字数を判定する必要がある。  
        　この様な文字をEOSと呼ぶ。C言語では'¥0'がEOSとして扱われる。数値としては0になる。
 
        ・EOS（End of String）
        　文字列の終わりを表す記号で終端文字とも呼ばれる。
  
  　　　　文字列の表現例：
      　　int main(void){
            char str[6] = { 'M', 'A', 'R', 'I', 'O', '\0' };  ➡　char str[6] = { 'M', 'A', 'R', 'I', 'O' }; でも0が入るため文字列扱いになる。
            printf("%s\n", str);  // 結果：MARIO
            return 0;
          }
　　　　　
     　　 文字列リテラルを使うことで省略化できるが、これは初期化の時にしか使えない。
        　int main(void){
            char str[] = "MARIO";
            printf("%s\n", str);  // 結果：MARIO
            return 0;
          }

　　　　　後から文字列を代入する場合は、1つ1つ要素に代入する必要がある。
      　　int main(void){
            char str[6];
            str[0] = 'M';
            str[1] = 'A';
            str[2] = 'R';
            str[3] = 'I';
            str[4] = 'O';
            str[5] = '\0';
            printf("%s\n", str);
            return 0;
          }
          
         ・文字列の連結
         　特に関数などは不要で直接並べるだけで連結できる。
          　char str[] = "DRAGON""QUEST";

　　　　　・文字数を数える
     　　　EOSが出現するまでの数を数えるだけでいい
        　　実装例：
          　int i;
            
            char str[256];
            scanf("%s", str);
            
            for(i = 0; i != '\0'; i++);
            printf("%d\n", i);
            
            strlen関数を使うのが一般的。
         
　　25．アドレス
　　　　アドレス　➡　変数に付けられたメモリ上での番号のこと。
　　　　printf関数で%p指定子を使うことで番号を調べられる。
　　　　変数名の前には&が必要。
　　　　配列は配列の最初の要素のアドレスを表し、各要素を参照するときに[0],[1]といった要素番号をつけるが、
　　　　これは配列名のアドレス+要素番号のメモリを参照する意味となる。
　　　　つまり、最初のアドレスを決めておけばそれに番号を足し算することでたくさんの変数が並んでいるという状態を表現することができる。
　　　　配列はint型であれば4バイトずつ連番が割り当てられている。
　　　　実行例：
    　　int array[10];
     　 printf("array___(%p)\n", array);　
　　　　printf("array[0](%p)\n", &array[0]);
　　　　printf("array[1](%p)\n", &array[1]);
　　　　printf("array[2](%p)\n", &array[2]);
　　　　printf("array[10](%p)\n", &array[10]);
　　　　結果：
    　　array___(000000000014FE98)
　　　　array[0](000000000014FE98)
　　　　array[1](000000000014FE9C)
　　　　array[2](000000000014FEA0)
　　　　array[10](000000000014FEC0)

　　26．&付き変数
  　　　&は変数のアドレスを求める演算子である。
　　　　値渡し　➡　関数に単なる数値として情報を渡す方法。
　　　　引数で変数を呼び出し、関数に渡す時、呼び出した関数の実引数に値がコピーされる。
　　　　重要なことは変数を実引数に指定しても、渡されるのは中身の数値であること。
　　　　もし、変数の中身を変更したい場合はこのコピーに対して変更を行っても意味がない。
　　　　そこで&演算子を使い、アドレスを求めてそのアドレスの数値を渡すと、
　　　　関数に呼び出し側の変数のアドレス、すなわちメモリ上の番号がわかり、その番号のメモリを書き換えることで変数を書き換えられる。
　　　　参照渡し　➡　アドレスを渡す処理。
     
　　27．ポインタ
  　　　ポインタ　➡　一般的にアドレスの値を記憶する変数のことをさす。
　　　　実際はポインタとはアドレスを扱う機能3つの総称である。
　　　　1．ポインタ型
　　　　　　アドレスを記憶する変数の型のこと。
　　　　　　ほかの型から作り出される派生型である。
　　　　　　それはどういうことかというと、ポインタ型は他の型とポインタ型を合体させて作るということ。
　　　　　　例えばint型とポインタ型を合体させるとintへのポインタ型という型になる。
　　　　　　合体する理由は指定アドレスに記憶された数値を取り出すためである。
　　　　　　int型は4バイトのサイズであるため、int型の値を取り出すためにはこの4個をまとめて取り出す必要がある。
　　　　　　元々の型が何だったのかがわからないと記憶された数値は取り出せない。つまりポインタ型はどんな型の変数のアドレスだったかわかる必要がある。
　　　　　　そこであらかじめほかの変数と合体した形でポインタ型として作っておけば、そのポインタ型の変数に記憶された数値は合体されている型であるとわかる。
      
　　　　2．ポインタ値
　　　　　　ポインタ型で扱える数値、要はアドレスの値のこと。
　　　　　　整数や実数といった数値の区別と同様にポインタ値という区別がある。
　　　　　　変数のアドレスは整数であるが、int型と区別することで意味や目的がはっきりとわかる。
      
　　　　3．ポインタ変数
　　　　　　ポインタ型で宣言された、ポインタ値を記憶できる変数のこと。
　　　　　　この変数には元となった型の変数のアドレスを自由に代入でき、記憶しているアドレスのメモリを読んだり書き換えたりできる。
　　　　　　ポインタ変数はポインタ変数モードと通常変数モードの2モードを備えており、必要に応じて切り替えることができる。
　　　　　　・ポインタ変数モード：
      　　　　アドレスへの代入と足し算引き算のみ。
 　　　　　　　これはポインタ変数モードに必要なものがアドレスの記憶だけだからである。アドレスさえ記憶していれば、あとは特になにもする必要がない。
　　　　　　・通常変数モード
　　　　　　　 通常の変数と同じ。
        　　　 切り替えは*を変数名の前に付けることで通常変数モードに変わる。
            　*p = 10;
       
      　　 ・ポインタ変数の宣言
         　　int *p;
             *がポインタ型を意味する記号。
             int型変数のアドレスを記憶するpという変数を宣言している。
             アドレスを変数に代入する時は適当な番号ではOSが異常動作だと判断し強制終了してしまうため、
             変数を作りそのアドレスを代入する。
             実装例：
             int *p;
             int i;
             p = &i;
             return 0;
             
             ヌルポインタ　➡　ポインタ変数は宣言した直後はでたらめな値が代入されており、これを使うとバグになる。
             　　　　　　　　　 そのためアドレスを代入したかどうか区別するためにヌルポインタが用意されており、
                       　　　　int *p = NULL;　or 0;　でアドレスが代入されておらず使えない状態であることを示す。
             
          ・ポインタ変数の役割
          　　すなわちショートカットである。
         　　 ポインタ変数に実際に存在する変数のアドレスを記憶しておけばそのポインタ変数が使える場所であれば、
        　　　元の変数が使えない場所であってもポインタ変数を通常変数モードに切り替えれば、元の変数と同じく使うことができる。

　　28．関数のポインタ型引数
  　　　使い方は普通の引数と変わらず、引数の型がポインタ型となるだけである。
  　　　関数の呼び出し時に既に存在する変数のアドレスを指定すれば、通常変更できない参照元の変数の値を変更することが可能となる。
　　　　実装例：
　　　　void func(int* pvalue); // プロトタイプ宣言
  　　　
　　　　int main(void){
           int value = 10;
           printf("&value = %p\n", &value); // valueのアドレス
           func(&value);  // アドレスを関数に渡す
           printf("value = %d\n", value); // 変更したvalueの値
           return 0;
       }
       
       int func(int* pvalue){
           printf("pvalue = %p\n", pvalue); // 引数のアドレス
           *pvalue = 100; // 通常変数モードに切り替えて代入
           return;
       }
       
       結果：
       &value = 000000000014FEBC
       pvalue = 000000000014FEBC
       value = 100
       
　　29．配列型のポインタ引数
  　　  配列は値渡しされずにアドレスが渡されている。
      　[]の要素番号を指定した場合は配列の先頭のアドレス（ポインタ値）に要素番号だけ足した結果を要素として扱う。
　　　  この性質を利用すればポインタ変数を配列に様に扱うことができる。
     　 実装例：
       int main(void){
          int *data;
          int i, average = 0, array[10] = {15, 78, 98, 15, 98, 85, 17, 35, 42, 15};
          
          data = array; // ポインタ変数に配列のアドレスを代入
          
          for(i = 0; i < 10; i++){
              average += data[i]; // 配列みたいに扱える
          }
          
          printf("%d\n", average / 10);
          return 0;
       }
       
       結果：
       49
       
       配列とポインタはよく混同されるが、全く別物である。
       配列はあくまでも多数の変数の先頭を示す固定された変数で、
       ポインタ変数は好きな変数のアドレスを代入して、好きなメモリ領域を使うことができる可変的な変数である。

　　30．ポインタ演算
  　　　*(ポインタ変数　+　要素番号）
     　 先頭の*はポインタ変数を通常変数モードに切り替えるための演算子。
        ポインタ変数のアドレス値に要素番号分の足し算を行い、結果のアドレス値を通常変数モードに切り替えることで
        先頭アドレスから指定数だけ進んだ先のメモリにアクセスする方法となる。
        
        29のコードを書き換えた例：
        int main(void){
          int *data;
          int i, average = 0, array[10] = {15, 78, 98, 15, 98, 85, 17, 35, 42, 15};
          
          data = array; // ポインタ変数に配列のアドレスを代入
          
          for( i = 0; i < 10; i++){
             average += *(data + i); // ポインタ演算
          }
          
          printf("%d\n", average / 10);
          
          return 0
        }
     
-------------------------------------------------------------

★　関数

　◎　#include <stdio.h>
      ・printf()
      ・scanf("%?", &val);
          %?　➡　入力変換指定子
          val　➡　変数名
      　　実装例：
        　#include <stdio.h>
  
          int main(void){
          	int data1, data2, sum;
          	printf("最大値と最小値をカンマ区切りで入力\n");
          	scanf("%d,%d", &data1, &data2);
          	sum = (data2 + data1) * (data2 - data1 + 1)/2;  
          	printf("%dと%dの合計は%dです。\n", data1, data2, sum);
          	return 0;
          }
          
          文字列を入力する場合は変数名前の&が不要になる。
          char str[32];
          scanf("%32s", str);  // 桁数を指定することで文字数がオーバーするエラーを防げる
          printf("%s\n", str);
      
      ・sprintf(array, str, val...);
          printf関数と同じ機能だが、結果を配列の中に記憶する。
          array　➡　結果を記憶する配列
          str　➡　書式文字列
          val　➡　各種変数
          実装例：
          char str[16];
          char str1[12] = "DRAGON";
          char str2[] = "QUEST";
          int i = 3;
          sprintf(str, "%s$s%d\n", str1, str2, i);
          printf(str);  // 結果：DRAGONQUEST3
  
　◎　#include <stdlib.h>
      ・atoi(str_array);
         str_array　➡　文字列配列名
         文字列を数値に変換した結果を変数に代入する
         実装例：
         char str[] = "145";
         int suuti = atoi(str);
         printf("%d\n", suuti);  // 結果：145
      ・atof()　➡　実数に変換

　◎　#include <math.h>
      ・pow(num,n);
         numのn乗を表す。
         pow(2, n); ➡　2のn乗

　◎　#include <string.h>
　　　 ・strcpy(str_array1, str_array2);
    　　　文字列配列同士のコピーに使うのが元々の役目だが、文字列の代入によく使われる。
          str_array1　➡　コピー先文字列配列名
          str_array2　➡　コピー元文字列配列名
          実装例：
          char str[10];
          strcpy(str, "MARIO");
          printf("%s\n", str);  // 結果：MARIO
          
      ・strncpy(str_array1, str_array2, str_count);
        　先頭から指定した文字数だけをコピーするが、最後にEOSが入っていない可能性があるため、必ず付ける。
        　 str_array1　➡　コピー先文字列配列名
           str_array2　➡　コピー元文字列配列名
           str_count　➡　コピーする文字数
           実装例：
           char str1[] = "MARIO", str2[10];
           strncpy(str2, str1, 3);
           str2[3] = '\0';  // EOSを付与
           printf("%s\n", str2);  // 結果：MAR
       
       ・strcat(str_array1, str_array2);
           配列に記憶された文字列を連結する。
           str_array1　➡　元の文字列が記憶された配列
           str_array2　➡　追加する文字列が記憶された配列
           実装例：
           char str1[12] = "DRAGON";  // 結合後の長さが必要
           char str2[] = "QUEST";
           strcat(str1, str2);
       
       ・strlen(str_array);
           文字列配列の長さを数える。
           str_array　➡　文字列配列
           実装例：
           int i;
           char str[256];
           scanf("%s", str);
           i = strlen(str);
           printf("%d\n", i);
       
       ・strcmp(str_array1, str_array2);
           文字列を比較して配列の中身が同じなら0を返す。
           str_array1　➡　文字配列1
           str_array2　➡　文字配列2
           実装例：
           cahr str1[256], str2[] = "DRAGONQUEST";
           scanf("%s", str1);
           if(strcmp(str1, str2) == 0){
              printf("同じ\n");
           }else{
              printf("違う\n");
           }
           

　◎　#include <memory.h>
 　　　・memcpy(array1, array2, array_size); 
　　　    array1の全要素をarray2へコピーする。
          array1　➡　コピー先配列名
          array2　➡　コピー元配列名
          array_size ➡　配列全体のサイズ
        　実装例：
         　memcpy(array2, array1, sizeof(array1));
　　　　　　バッファオーバーラン　➡　memcpy関数は配列の長さを考慮しない。コピー元の配列がコピー先より長くても無理やりコピーしてしまうため、
      　　　　　　　　　　　　　　　　はみ出たデータは別の変数や配列に上書きされてしまう。結果、重大なエラーとなる。
                      
　◎　#include <ctype.h>
       ・isalnum(val);
       　　引数が英数字（A-Za-z0-9）かどうか判定する。
           val　➡　判定する変数名
       ・isdigit()  10進数（0-9）かを判定
       ・isxdigit()  16進数（A-Fa-f0-9)かを判定
       ・isalpha()  英字（A-Za-z）かを判定
       ・isupper()　英大文字（A-Z）かを判定
       ・islower()　英小文字（a-z）かを判定
       ・ispunct()　記号（!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~）かを判定
 

-------------------------------------------------------------

★　用語

・アセンブラ
　低級言語。コンピュータが理解できる言語でマシン語（機械語）のこと。
 
・コンパイル
　プログラミング言語を機械語に翻訳すること。翻訳する機能を持つものをコンパイラという。
　コンパイラの3段階の動作
　1．プリプロセッサというソフトが文字列の調整（空白や改行の結合、記号の置き換えなど）を行い、プログラムを解析しやすくする。
　2．コンパイラがコンパイルする。この時に最適化（より高速に動作するように工夫してマシン語に翻訳する機能）を行う。
　3．翻訳した機械語プログラムがリンカというソフトによって結合（リンク）され、マシン語のデータが実行可能ファイル（EXEファイル）になる。

・インタプリタ
　プログラムを読み込むと同時に翻訳する機能のこと。
 
・擬似命令
　プログラムコードではなく、機械語に翻訳されずその前段階で処理される。
　#includeはprintf関数などの準備をするための命令。

・エスケープシーケンス
　画面に表示できない制御を行うために使われる特殊文字。
　改行　➡　\n
　タブ　➡　\t

・数値と数字
　数値は数を表現するもので計算に使える。
　数字は見た目は同じだが、数を表現するものではなく、計算に使えない。

・文字列リテラル
　"”で囲われた文字定数。
 
・整数と実数
　整数は自然数に0と負の数を加えた数のこと。
　実数は整数に小数値を加えた数のこと。

・浮動小数点方式
　実数値を数値の並び（仮数部）と小数点の位置（指数部）で表す方法。

・出力変換指定子
　外部のデータを文字列に変換して表示したい時にその変換方法を指定する記号。
　 整数値を文字列に変換する　➡　%d　指定子
　　例：printf("%d+%d=%d\n", 100, 200, 300);
   桁数を指定する　➡　%桁数d
    例：printf("%5d", 500);  // 空白→  500
   空白を0にする　➡　%0桁数d
    例：printf("%5d", 500);  // 00500
   実数値の桁をそろえる　➡　%全体桁数.少数桁数f  全体桁数は少数の桁数と小数点を含む
    例：printf("%6.2f", 3.14159);  // 3.14
   実数値を数字に変換する　　➡　%f　指定子
　　例：printf("%f\n", 10.0 + 3.0);   // 13.00
       printf("%f\n", 10.0 - 3.0);   // 7.00
       printf("%f\n", 10.0 * 3.0);   // 30.000
       printf("%f\n", 10.0 / 3.0);   // 3.3333
   文字を入れる　➡　%c
    例：printf("%c\n", 'A');
   
   入力値の場合
   文字を入力する　➡　%c 指定子　char
   文字列　➡　%s 指定子　char
   10進数の整数　➡　%d 指定子　int, short
   浮動小数点数　➡　%f 指定子　float
   実数(倍精度浮動小数点数）　➡　%lf　指定子　double
       
・キャスト変換
　強制的に型を変換する機能。
　型の記載例：
  （変換する型）数値や変数名
　　(int)(1.05 * 360)); // 378

