
サイバー攻撃について

長谷川陽介さんの「教科書に載らないWebアプリケーションセキュリティ」　https://atmarkit.itmedia.co.jp/fcoding/index/webapp.html

------------------------------------------------------------------

★　表示処理に伴う脆弱性

◎　XSS（クロスサイトスクリプティング）
・概要
攻撃者はインターネット掲示板などの動的なWebサイトにある入力フォームにワナ（脆弱性のあるサイトへ誘導するスクリプトを含んだリンク）を設置する。
リンクをクリックしてこのようなサイトに誘導されると、ユーザーのブラウザ上で不正なスクリプトが実行され、
入力した情報やCookieなどが攻撃者へ漏えい、マルウェアへの感染、なりすましなどの被害が発生する。

・原因
入力値が制限されていなかったり、入力したスクリプトをそのまま実行できる状態にあり、攻撃者が容易に不正なスクリプトを入力できてしまうことがあげられる。

・種類
　1．Reflected XSS（反射型XSS）
　　　攻撃者は偽メールや偽サイトに不正なスクリプトを含んだリンクを用意し、脆弱性のあるWebサイトに誘導する（リクエストさせる）ことで
　　　ユーザーのブラウザで不正なスクリプトを実行させ、情報の搾取やマルウェアのダウンロードを行う。

　2．Stored/Persistent XSS（格納型/蓄積型/持続型XSS）
　　　攻撃者はあらかじめWebアプリケーションに直接スクリプトを格納する。
　　　該当のページをユーザーが閲覧するたびに、不正なスクリプトが実行される。
　　　該当ページにアクセスするだけであるため、Reflected XSSと比べると
　　　ワナを仕掛けたWebサイトを準備したり、スクリプトを含んだリンクをメール送信したりしなくても攻撃が成立する点では効率的である。
    　WebメールやSNSなどが典型的な攻撃ターゲット。
      メリット：罠サイトに利用者を誘導する手間がかからないこと
      　　　　　注意深い利用者でも被害にあう可能性が高いこと

　3．DOM Based XSS
　　　Webブラウザで動作するJavaScript上のコードの脆弱性を悪用した攻撃で、サーバー側で攻撃用スクリプトが実行されるのではなく、
　　　クライアントのWebブラウザ上で不正なスクリプトが実行される。
　　　また、DOM Based XSSは静的なHTMLにおいてもJavaScriptが利用されていれば攻撃対象となる。
   　 HTML上には攻撃者が注入したJavaScriptが現れない攻撃。
      textメソッドを使うことで自動的にエスケープされて要素に追加される。
      実装例：
      <body>
      <script src="jquery-1.4.4.min.js"></script>
      こんにちは<span id="name"></span>さん
      <script type="text/javascript">
      if(document.URL.match(/name\=([^&]*/)) {
        var name = unescape(RegExp.$1);
        $('#name').text(name);
      }
      </script>
      </body>

・被害
　1．セッションハイジャック
　2．個人情報の流出
　3．Webページの改竄

・対策
　1．サニタイジング（エスケープ）処理をする
 　　・要素内容については「<」と「&」
   　・属性値についてはダブルクォートで囲い、「<」と「"」と「&」　をそれぞれエスケープする
　　  ブラウザで「<」という文字を表示させる場合は、文字参照により「&lt;」と記述（エスケープ）する必要がある。
     これを「<」のままHTMLを生成すると、ブラウザは「<」をタグの開始と解釈する。これを悪用したのがXSS攻撃。
　　　「<」や「””」といった区切りやタグなどの意味を持つ文字を意味を持たない文字列に置き換え無害化する行為である、
　　　サニタイジングを行うことでスクリプトが意図せずに挙動することを防ぐことができる。
   　　PHPではhtmlspecialchars関数で対策できる。
     　string htmlspecialchars(string $string, int $quote_style, string $charset)
       第1引数…変換対象の文字列　第2引数…引用符の変換方法　第3引数…文字エンコーディング
       
       引用符の変換
       変換前　　|　変換後　　|　ENT_NOQUOTES　|　ENT_COMPACT　|　ENT_QUOTES　|
       　 <         &lt;           〇　　　　　　　　〇　　　　　　    〇
        　>　　　　　&gt;           〇      　  　   〇               〇
          &         &amp;          〇              〇               〇
          "        &quot;          ×               〇               〇
          '        &#39;           ×               ×                〇
          
        ➡　要素内容　➡　$quote_styleはどれでもよい
        　　属性値　　➡　ダブルクォーテーションで囲み、$quote_styleはENT_COMPACT、もしくはENT_QUOTES

　2．バリデーション処理（入力値の制限）
　　　例えば、パスワード入力欄に「全角英数字の6文字」、電話番号入力欄に「数字のみ」などの制限を入れることで不正なスクリプトを入力させない。
　　　JavaScriptを使い、ブラウザ側で入力値の制限を行ってしまうと、ユーザー側がJavaScriptをオフにして不正なスクリプトを入力ができるため、必ずサーバー側で制限を実施する。
   
　3．WAFを設置する
　　　WAF（Web Application Firewall）はWebアプリケーションを対象とした攻撃を検知・防御するセキュリティ製品。
　　　自社においてオープンソースのシステムを利用していたり、CMSやフレームワークを使ってWebサイトを構築していたりする場合、
　　　全ての脆弱性修正に対応するのは限界があるため、WAFの導入は必要不可欠である。

　4．出力時はhttpやhttpsから始まるURLのみ許可する
　　　URLに「JavaScriptスキーム」や「dataスキーム」などが含まれている場合でも、クロスサイトスクリプティングのリスクが生じる。
　　　入力するリンク先のURLはhttpやhttpsから始まるもののみを許可する設定にすることで想定外の処理がされるリスクを防げる。
   
  5．クッキーにHttpOnly属性を付与する　
  　　この属性はJavaScriptからのクッキーの読み出しを禁止するというもの。
    　セッションIDの盗み出しには効果があるが、その他の攻撃には有効ではない。
      これはphp.iniに「session.cookie_httponly = On　」と追加することでできる。

　6．TRACEメソッドの無効化
 　　　クロスサイトトレージング（XST）という攻撃の対策。
    　　XST…JavaScriptによりHTTPのTRACEメソッドを送信することでクッキー値やBasic認証のパスワードを盗む方法。
      　XSS攻撃を完全に解消できれば、問題はない。
        最近のブラウザではXST対策がなされている。
        TRACEメソッドの無効化はhttpd.confに「TraceEnable　Off」と追加する。
        
  7．URLを生成する際の対策
  　　URLをプログラムで作成する場合はhttpスキームとhttpsスキームのみを許可するようにチェックする必要がある。
    　具体的にはURLとしては以下のいずれかのみを許容するようにチェックする。
     　・http:　または　https:　で始まる絶対URL
       ・スラッシュ「/」で始まる相対URL
       チェックする関数
       function check_url($url){
            if(preg_match('/\Ahttp:/', $url) ||
               preg_match('/\Ahttps:/', $url) ||
               preg_match('#\A/#', $url)) {
                return true;
            }else{
                return false;
            }
        }
        
  8．リンク先ドメインのチェック
  　　リンク先として任意のドメインのURLを指定できる場合、利用者が気付かない内に罠のサイトに誘導され、
    　フィッシングの手法で個人情報等を入力させられる可能性がある。
     　対策
       ・リンク先を検証してURLが外部ドメインである場合はエラーにする
       ・外部ドメインへのリンクであることを利用者に注意喚起するためのクッションページを表示する
       
  9．イベントハンドラのXSSはJSをエスケープする必要がある
  　　JSを動的生成するケースでは入力パラメータ中のシングルクォート「'」がデータとしての文字「'」ではなく、
    　JSの文字列の終端に使われてしまうことが原因で脆弱性が発生する。
       対策
     　・データをJavaScript文字列リテラルとしてエスケープする
       ・この結果をHTMLエスケープする
       
       JavaScriptの文字列リテラルとしてエスケープすべき文字
       　文字　　　|　エスケープ後
        　\           \\
          '           \'
          "           \"
         改行         \n
         
         そのため入力に「<>'"\」が与えられた場合は以下の様にエスケープする必要がある。
         　元入力　<>'"\　➡　JavaScriptエスケープ後　<>\'\"\\　➡　HTMLエスケープ後　&lt;&gt;\&#39;\&quot;\\

　10．script要素のXSS
 　　　入力中に「</script>」が含まれている場合、そこでJavaScriptのソースの終端となり、
    　　再度「<script>alert(document.cookie)//」などと入れることでXSS攻撃が可能である。
      
  11．JavaScriptの動的パラメータ生成時の対策
  　　1．Unicodeエスケープによる対策
    　　英数字以外をすべてエスケープする手法で、UnicodeコードポイントU+XXXXの文字を\uXXXXという形でエスケープする機能を利用する。
      　Unicodeエスケープする関数escape_js_stringは文字エンコーディングがUTF-8であることが前提だが、
        英数字に加えてマイナス記号「-」とピリオド「.」をエスケープしない仕様になっている。
        実装例：
        <?php 
         // 文字列を全て\uXXXX形式に変換する
         function unicode_escape($matches){
            $u16 = mb_convert_encoding($matches[0], 'UTF-16');
            return preg_replace('/[0-9a-f]{4}/', '\u$0', bin2hex($u16));
         }
         // 英数字とマイナス、ピリオド以外を\uXXXX形式でエスケープする
         function escape_js_string($s){
            return preg_replace_callback('/[^-\.0-9a-zA-Z]+/u', 'unicode_escape', $s);
         }
         ?>
         
         スクリプトの説明
         ・unicode_escape関数は入力文字列をすべて\uXXXXというUNICODE形式でエスケープする
         ・mb_convert_encodingで入力をUTF-16でエンコーディングする
         ・bin2hexで16進数文字列に変換する
         ・正規表現により4バイト毎に「\u」を挿入する
         ・escape_js_string関数は入力文字列の中から、英数字以外を\uXXXX形式でエスケープする
         ・preg_replace_callback関数により英数字以外からなる文字列をunicode_escape関数に引き渡す
         
      2．script要素の外部でパラメータを定義して、JavaScriptから参照する方法
      　　hiddenパラメータを利用する。
        　実装例：
          <input type="hidden" id="familyname" value="<?php echo htmlspecialchars($familyname, ENT_COMPACT, 'UTF-8'); ?>">
          ...
          <script type="text/javascript">
          var familyname = document.getElementById('familyname').value;
          //..
          
          2行目で値を設定する際に属性値に対するエスケープ原則に従い、htmlspecialchars関数でエスケープした値をダブルクォートで囲んでいる。
          そのinputの値をgetElementByIdメソッドにより参照している。


◎　CSRF（クロスサイトリクエストフォージュリ）
・概要
　「重要な処理」の脆弱性があるとクロスサイトリクエストフォージェリが生じる可能性がある。
 　重要な処理…クレジットカードでの決済、利用者の口座からの送金、メール送信、パスワードやメールアドレスの変更
  重要な処理の受付に関しては、利用者の意図したリクエストであることを確認する必要があるが、
  この確認処理が抜けていると、罠のサイトなどを閲覧しただけで利用者のブラウザから勝手に重要な処理を実行させられることがある。
  WebアプリケーションにCSRF脆弱性がある場合の影響
  ・利用者のアカウントによる物品の購入
  ・利用者の退会処理
  ・利用者のアカウントによる掲示板への書き込み
  ・利用者のパスワードやメールアドレスの変更
  

・原因
　脆弱性が生まれる背景に以下のWebの性質がある。
　1．form要素のaction属性にはどのドメインのURLでも指定できる
 　　罠などのサイトからでも攻撃対象サイトにリクエストを送信できること。
　2．クッキーに保管されたセッションIDは、対象サイトに自動的に送信される
　　 罠経由のリクエストに対しても、セッションIDのクッキー値が送信されるため、認証された状態で攻撃リクエストが送信されるということ。
   
   通常のWebアプリケーションではRefererの値をチェックしないため、アプリケーション開発者が意識して、
   正規利用者の意図したリクエストであることを確認しない限り、区別されないため、CSRF脆弱性の可能性がある。
   また、クッキー以外にも自動的に送信されるパラメータを使ってセッション管理しているサイトにはCSRF脆弱性の可能性がある。
   具体的にはHTTP認証、SSLクライアント認証、携帯電話の携帯IDによる認証を利用しているサイトも攻撃の影響を受ける可能性がある。
 

・対策
　設計段階から対策を盛り込む必要がある。
　主に「重要な処理」とされるリクエストが正規利用者の意図したものであることを確認する必要がある。
 
 ・CSRF対策の必要なページを区別する
 　CSRF攻撃は全てのページで対策する必要はない。
　 例えばECサイトであれば、商品カタログページは外部からリンクされることが好ましく対策の対象ではない。
   一方、購入ページやパスワード変更、個人情報編集などは勝手に実行されると困るため、対策が必要である。
   
   開発プロセスで以下の様にする。
   1．要件定義工程で機能一覧を作成し、CSRF対策の必要な機能にマーク
   2．基本設計工程で画面遷移図を作成し、CSRF対策の必要なページにマーク
   3．開発工程でCSRF対策を作りこむ
   
 ・正規利用者の意図したリクエストを区別できるよう実装する
 　CSRF対策として必要なことは正規利用者の意図したリクエストであることの確認である。
   正規利用者の意図したリクエストとは、対象のアプリケーションの画面上で正規利用者が自ら実行ボタンを押した結果のリクエストである。
   正規サイト　➡　正規のサイトのボタン押下によるリクエストは、正規利用者の意図したリクエストとみなせる。
   罠サイト　　➡　罠のサイトを閲覧しただけで送信されるリクエストは正規利用者の意図したリクエストではない。
   具体的に見極める方法
   1．秘密情報（トークン）の埋め込み
   2．パスワード再入力
   3．Refererのチェック
   
   1．秘密情報（トークン）の埋め込み
   　トークンとは、第三者が知り得ない秘密情報のこと。
     トークンを簡便且つ、安全に実装する方法として、セッションIDをトークンとして利用可能である。
     トークン埋め込み実装例：
     <form action="chgpwddo.php" method="POST">
        新パスワード<input name="pwd" type="password"><br>
        <input type="hidden" name="token" value="<?php echo htmlspecialchars(session_id(), ENT_COMPAT, 'UTF-8'); ?>">
        <input type="submit" value="パスワード変更">
     </form>
     
     トークン確認の実装例：
     session_start();
     if(session_id() !== $_POST["token"]){
        die("正規の画面からご使用ください"); 
     }
     // 以下、重要な処理の実行
     
     入力ー確認ー実行のように3段階の遷移がある場合でも、トークンを埋め込むページは実行ページの直前のページである。
     また、トークンはPOSTで受け取る必要がある。
     
   　・ワンタイム・トークンについて
    　　ワンタイム・トークン　➡　使い捨てのトークンであり、必要になる度に異なる値を生成する。生成には暗号論的擬似乱数生成器を使う。
      　ワンタイム・トークンを使う典型的なケースはリプレイ攻撃対策が必要な場合である。
        リプレイ攻撃　➡　暗号化されたリクエストを盗聴してその内容を丸ごと再送する成りすまし攻撃のこと。
        本書ではワンタイム・トークンを推奨しない。
        1．CSRF攻撃は盗聴やリプレイ攻撃とは無関係であり、ワンタイム・トークンを用いる必然性がない。
        2．ワンタイム・トークンがセッションIDそのものをトークンとする方法に比べて安全になる根拠がない。
        3．ワンタイム・トークンを用いることで正当な操作までエラーになる場合がある。
 
 　2．パスワード再入力
 　　パスワードの再入力を求めることで利用者の意図したリクエストであることを確認できる。
   　また、次の目的でも使われる。
   　1．物品の購入などに先立って、利用者の意思を念押しして確認する
   　2．共有PCで別人が操作している状況などがなく、本当に正規の利用者であることを確認する
    いずれも最終の実行ページで行うように実装する。
    
  3．Refererのチェック
  　「重要な処理」を実行するページでRefererをチェックする。
  　実装例：
   if(preg_match('#\Ahttp://example.jp/45/45-002ch.php#', @$_SERVER['HTTP_REFERER']) !== 1){
        die('正規の画面から実行してください');
   }
   
   最も手短に対策ができる反面、RefererのチェックはRefererを送信しないように設定している利用者には実行できないという欠点がある。
   パーソナルファイアウォールやブラウザのアドオンソフトなどでRefererを抑止している、そもそも送信されない（古いiモードの携帯など）場合がある。
   そのため、Refererのチェックで対策を行うのは社内用のシステムなどに限るべきである。
   
   
・保険的対策
　重要な処理の実行後に利用者に処理内容の通知メールを送信することが推奨される。
　CSRFだけでなくXSSに対しても有用で防ぐことはできないが、早期に発見することで被害を最小限に抑えることができる。
   

・CSRFとXSSの比較
攻撃に至るシナリオが似ており、攻撃の影響が一部重なるため、混同しやすいが、別物である。
シナリオを以下に示し、違いを見る。
1．被害者が攻撃者の罠サイトを閲覧
2．仕掛けのあるHTMLがブラウザに返される
3．攻撃用リクエストが正規のサイトに送られる
4．仕掛けを含むレスポンスが正規のサイトからブラウザに返される
CSRFは3.のリクエストに対するサーバー側の処理を悪用するもの。
XSSは3.のリクエストに含まれるスクリプトはオウム返しに4.のレスポンスとして返され、
それがブラウザ上で実行されることで攻撃が起こる。ブラウザ上でできることは何でもできるため、
JavaScriptを使ってサーバー側の機能を悪用することもできる。


-----------------------------------------------------------------------------------------------------------

★　SQL呼び出しにおける脆弱性

◎　SQLインジェクション
・概要
　　SQLの呼び出し方に不備がある場合に発生する脆弱性。
 　・データベース内の全ての情報が外部から盗まれる
   ・データベースの内容が書き換えられる
   ・認証を回避される（IDとPASSを使わずにログインされる）
   ・その他、データベースサーバー上のファイルの読み出し、書き込み、プログラムの実行など

・攻撃の種類
　1．UNION SELECTを用いた情報漏洩
  2．SQLインジェクションによる認証回避
  3．SQLインジェクション攻撃によるデータ改ざん
  4．その他の攻撃
  　　・OSコマンドの実行
    　・ファイルの読み出し、書き出し
    　・HTTPリクエストのより他のサーバーを攻撃

・原因
　リテラルの扱いに原因がある。
　リテラルとはSQL中で決まった値を示すもので、文字列リテラルと数値リテラルが頻繁に利用される。
　SQLの標準規格では文字列リテラルをシングルクォートで囲み、文字列リテラル中にシングルクォートを含む場合は
　シングルクォートを重ねる決まりである。
　SQL脆弱性のあるプログラムはこのシングルクォートを重ねる処理が抜けているため、
　最初のシングルクォートで文字列リテラルが終了され、その後に悪意のあるSQLを注入されて攻撃が発生する。
　数値リテラルも同様に数字以外が入るとリテラルが終了する。
　例えば「;」が入った後に悪意のあるSQLで攻撃される。

・対策
　1．プレースホルダによりSQL文を組み立てる
　2．アプリケーション側でSQL文を組み立てる際に、リテラルを正しく構成するなど、SQLが変更されないようにする
 　2は完全な対応が難しいため、1の方法が良い。
  
  プレースホルダ
  ・2種類のプレースホルダ
  　1．静的プレースホルダ
   　　値のバインドをデータベースエンジン側で行う。
     　プレースホルダのついたSQL文はそのままデータベースエンジンに送られ、コンパイルなどの実行準備が行われ、SQL文が確定する。
　　　　バインド値がデータベースエンジンに送られ、エンジン側で値を当てはめた後にSQL文が実行される。

　　2．動的プレースホルダ
  　　　SQLを呼び出すアプリケーション側のライブラリ内でパラメータをバインドしてデータベースエンジンに送る。
　　　　バインドにあたりリテラルは適切に構成されるため、処理系にバグが無ければSQLインジェクションは発生しない。
    
    どちらかといえば静的プレースホルダが優れているため、そちらを使うべき。
    
 ・検索条件が動的に変わる場合のプレースホルダ対策
 // 基本となるSQL
 $sql = 'SELECT id, title, author, publisher, date, price FROM books';
 if($title !== ''){  // 検索titleの追加（LIKE)
     $conditions[] = "title LIKE ? ESCAPE '#'";
     $ph_type[]    = 'text';
     $ph_value[]   = escape_wildcard($title);
 }
 if($price !== ''){  // 検索条件priceの追加（大小比較）
     $conditions[] = "price <= ?";
     $ph_type[]    = 'integer';
     $ph_value[]   = $price;
 }
 if(count($conditions) > 0){  // WHERE句がある場合
     $sql .= ' WHERE ' . implode(' AND ', $conditions);
 }
 $smt = $mdb2 -> prepare($sql, $ph_type);  // SQL文の準備
 $rs  = $stmt -> execute($ph_value);  // バインド・問い合わせ実行
 

・ ORDER BY 句
　ORDER　BY 句の後もセミコロンで第二SQLを実行できる。
  対策として　ソート列名の妥当性確認を行う方法がある。
  例：
  $sort_columns = array('id', 'author', 'title', 'price');
  $sort_key = $_GET['sort'];
  if(array_search($sort_key, $sort_columns) !== false){
     $sql .= ' ORDER BY ' . $sort_key;
  }
  
  
・保険的対策
　1．詳細なエラーメッセージの抑止
  2．入力値の妥当性検証
  3．データベースの権限設定
  

    
・参考
　a.ワイルドカードのエスケープ
 　%などのワイルドカードを検索したい文字列として加えるにはエスケープする必要がある。
 　例：「#」を用いてエスケープする
  　WHERE name LIKE '%#%%' ESCAPE '#'
   「#%」で%を意味する
   関数例：
   function escape_wildcard($s){
        return mb_ereg_replace('([_%#])', '#\1', $s);
   }
   
   mb_ereg_replace()
   第一引数に変換するターゲットの正規表現パターン
   第二引数に変換後の文字列
   第三引数に対象文字列
   第四引数にオプション
        　i …大文字・小文字が 区別されなくなる
　        x …空白を無視
　        m …マルチラインモード。改行も 正規表現"." に含まれる。
　        p …POSIX モード。改行も通常文字とみなされる
　        e …文字列引数 $replacement がPHPの式として評価される
         

  b.PHP+PDO+MySQLの安全な接続方法
  　PDOはデータベース接続時に文字コードを指定する方法が用意されていないため、
    MySQLの設定ファイル名を指定する方法で文字コードを指定する。
    例：
    $dbh = new PDO('mysql:host=localhost;dbname=wasbook', 'username', 'password', 
                    array(
                        PDO::MYSQL_ATTR_READ_DEFAULT_FILE => '/etc/mysql/my.cnf',
                        PDO::MYSQL_ATTR_READ_DEFAULT_GROUP => 'client',
                        PDO::ATTR_EMULATE_PREPARES => false,
                    ));
     更に/etc/mysql/my.cnf（MySQLの設定ファイル）に次の設定を追加する。
      [client]
      default-character-set=utf8


-----------------------------------------------------------------------------------------------------------

★　セッションにおける脆弱性

◎　セッションハイジャック
・概要
　何らかの原因で利用者のセッションIDが第三者に知られて、成りすましてアクセスされて悪用されること。
　セッションIDを第三者が知る方法は以下の3種類である。
　1．セッションIDの推測
 　　セッションIDの生成方法が不適切な場合、推測されてハイジャックされる。
   　連番や日時、ユーザーIDを元にセッションIDを生成している、オープンソースなソフトウェアで生成ロジックが公開されている場合など。
     攻撃対象：アプリケーション　自作セッション管理機構の脆弱性
     　　　　　ミドルウェア　　　ミドルウェアの脆弱性
          
    ・攻撃手法と影響
    　攻撃は次の3ステップで行われる。
      1．対象アプリケーションからセッションIDを集める
      2．セッションIDの規則性の仮設を立てる
      3．推測したセッションIDを対象アプリケーションで試す
      
      ありがちなセッションID生成方法
      ・ユーザーIDやメールアドレス
      ・リモートIPアドレス
      ・日時（UNIXタイムの数値、あるいは年月日時分秒の文字列）
      ・乱数
      
      ユーザーIDや日時は外部から推測可能な元データのため、脆弱性の原因になる。
      攻撃者は推測したセッションIDで攻撃し、成功したら成りすましができる。
      成りすましができてもパスワードはわからないため、重要な処理前のパスワードの再入力は保険的な対策になる。
      
    
　2．セッションIDの盗み出し
 　　盗み出す方法。
  　 ・クッキー生成の際の属性の不備により漏洩
     ・ネットワーク的にセッションIDが盗聴される
     ・クロスサイトスクリプティングなどアプリケーションの脆弱性により漏洩
     ・PHPやブラウザなどプラットフォームの脆弱性により漏洩
     ・セッションIDをURLに保持している場合、Refererヘッダから漏洩
     脆弱性の典型例
     ・クロスサイトスクリプティング
     ・HTTPヘッダ・インジェクション
     ・URLに埋め込まれたセッションID
     攻撃対象：アプリケーション　 XSS脆弱性（XSS）
     　　　　　                 HTTPヘッダ・インジェクション脆弱性（HTTPヘッダインジェクション）
                          　　 URL埋め込みのセッションID（Refererの悪用）
   　　　　　　ミドルウェア　　  ミドルウェアの脆弱性（アプリケーションと同様）
         　　　ネットワーク　　  クッキーのセキュア属性不備ほか（ネットワーク盗聴）
            
     a.URL埋め込みのセッションID
     　セッションIDをクッキーに保存せずにURLに埋め込まれている場合、
       Refererヘッダを経由してセッションIDが外部に漏洩し、なりすましの原因になる。
       PHP、Java、ASP.NET、ドコモの携帯電話ブラウザなど。
       
       ・攻撃手法と影響
       PHPの設定でセッションIDの管理を変更する。
       php.iniの設定項目
       session.use_cookies　セッションIDの保存にクッキーを使う　デフォルトで有効
       session.use_only_cookies　セッションIDをクッキーのみに保存する　デフォルトで有効
       session.use_trans_sid　セッションIDをURLに自動埋め込みする　デフォルトで無効
       
       ・refererによりセッションIDが漏洩する条件
       　1．URL埋め込みのセッションIDを使える
         2．外部サイトへのリンクがある。あるいはリンクを利用者が作成できる
         
       ・攻撃のシナリオ
       　意図的に攻撃を仕掛けることができるのは利用者がリンクを作成できる場合に限られる。
         具体的にはWebメール、掲示板、ブログ、SNSなどである。
         攻撃者がターゲットに対してURL付きのメールを送り、攻撃者のサイトへと誘導。
         ターゲットがサイトを閲覧するとWebメールのURLに埋め込まれていたセッションIDが攻撃者のサイトにRefererとして漏洩する。
         影響はセッションハイジャックと同等。
            
　3．セッションIDの強制（セッションフィクセーションの項へ）
　　　セッションIDを利用者のブラウザに設定することでセッションIDを知っている状態にすることでハイジャックを行う。
  　  セッションIDの固定化攻撃と呼ぶ。　
      攻撃対象：アプリケーション　セッションIDの固定化脆弱性（セッションIDの固定化攻撃）
 
 ・セッションハイジャックの影響
 　1．利用者の重要情報の閲覧
   2．利用者の持つ権限での操作
   3．利用者のIDによるメール、ブログなどへの投稿、設定の変更など
 

・原因
　1．セッションIDの推測の原因
 　　セッション管理機構を自作していること。
   　独自にセッション管理機構を作成する意味はない。
    　1．主要なWebアプリケーション開発ツールはセッション管理機構を備えている
    　2．安全なセッションID生成プログラムを開発することは技術的難易度が高い
  
  2．セッションIDの盗み出し
  
  　a.URL埋め込みのセッションIDの原因
  　　不適切な設定、あるいはプログラミングが原因。
    　意図的に設定するケースもあるが、基本的にセッションIDはクッキーに保存すること。
    　 

・対策
　1．セッションIDの推測の対策
   　現実的で効果的な対策は、Webアプリケーション開発ツールが備えるセッション管理機構を利用すること。
     どうしても自作する場合には、暗号論的擬似乱数生成器を基に十分な桁数のセッションIDを生成する。
     暗権論的擬似乱数生成器　➡　現実的な時間内に乱数値を予測することができないことを理論的に保証されている乱数。
     
     ・PHPのセッションIDのランダム性を改善する方法
     　PHPはデフォルト設定でMD⑤ハッシュ関数を通す方法でセッションIDを生成している。
       ・リモートIPアドレス
       ・現在時刻
       ・乱数（暗号論的擬似乱数生成系ではない）
       これらの組み合わせでセッションIDを生成しており、これは安全性が保証されていない設計である。
       php.iniに以下の設定を行うことで安全な乱数を元にセッションIDを生成できる。
       [Session]
       ;; entropy_file　は　Windowsでは設定不要
       session.entropy_file = /dev/urandom
       session.entropy_length = 32
       
       /dev/urandomはLinuxなどの多くのUnix系OSで実装されている乱数生成器である。
       
　2．セッションIDの盗み出し
 　　a.URL埋め込みのセッションIDの対策
   　　・PHPの場合
        [Session]
     　 session.use_cookies = 1
      　session.use_only_cookies = 1
       
      ・ASP.NETの場合
      <?xml version="1.0" encoding="UTF-8" ?>
      <configuration>
        <system.web>
            <sessionState cookieless="false" ?>
        </system.web>
      </configuration>


◎　セッションフィクセーション
・概要
　外部からセッションIDを強制することで成りすまし攻撃をする。
　手順
　1．セッションIDを入手する
　2．ターゲットに対して1のセッションIDを強制する
　3．ターゲットが標的アプリケーションにログインする
　4．攻撃者はターゲットに強制したセッションIDを使ってログインする

　ターゲットのセッションIDを強制することで攻撃者はそのセッションIDを使えば、ページにログインした状態になる。

　・クッキーのみにセッションIDを保存するサイトのセッションフィクセーション
　　クッキーのセッションIDを外部から設定することは通常不可能であるが、アプリケーションに脆弱性があれば可能になる。
  　・クッキーモンスター問題
  　・クロスサイトスクリプティング脆弱性
  　・HTTPヘッダ・インジェクション脆弱性

・原因
　セッションIDを外部から設定できること。
　以下の対策を行えば基本的には防げることである。
　1．セッションIDをURL埋め込みにしない
　2．クッキーモンスター問題のあるブラウザを使わない（使わせない）
　3．クッキーモンスター問題の発生しやすい地域型ドメインを使わない
　4．クロスサイトスクリプティング脆弱性をなくす
　5．HTTPヘッダインジェクション脆弱性をなくす
　6．その他クッキーを書き換えられる脆弱性をなくす
　ただし、これらをすべて行うのは不可能なため、セッションフィクセーションが発生してもセッションハイジャックを防ぐのが一般的。

・対策
　1．認証後にセッションIDを変更する
　PHPの場合
　bool session_regenerate_id([bool $delete_old_session = false])
　第一引数　➡　変更前のセッションIDに対応するセッションを削除するかどうか。基本trueにする。
 
　2．セッションIDが変更できない場合はトークンにより対策する
　ログイン時にトークンを生成し、クッキーとセッション変数の両方に記憶させる。
　各ページの認証確認時にクッキー上のトークンとセッション変数のトークンの値を比較し、同一である場合のみ認証されていると判断する。
　トークンが外部に出力されるのはログイン時のクッキー生成のみのため、攻撃者にとっては未知の情報である。
 
　・ログイン前のセッションフィクセーションの対策
　　ログイン前にセッション変数を使っているとセッションフィクセーションを防ぐのは不可能。
　　保険的対策として、
　　・ログイン前のセッション変数には秘密情報を格納しない
　　・URL埋め込みのセッションIDを使わない
　　・地域型ドメインを使わない
 

・セッションアダプション
　未知のセッションIDを受け入れるという特性。
　PHPやASP.NETはこの特性を持っている。
　セッションアダプションが無くてもセッションフィクセーションが防げるわけではないが、
　攻撃者の攻撃手順が増えることにはなる。（有効なセッションIDを取得するという手順が増える）


-----------------------------------------------------------------------------------------------------------

★　リダイレクト処理における脆弱性

◎　オープンリダイレクタ脆弱性
・概要
　リダイレクタ　➡　ログインページのパラメータにURLを指定しておき、ログイン後にそのURLにリダイレクトする機能。
　リダイレクタの中で任意のドメインにリダイレクトできるものをオープンリダイレクタという。
　オープンリダイレクタは利用者が知らないうちに別ドメインに遷移する場合、フィッシングという詐欺に悪用される可能性がある。
　フィッシング　➡　著名なWebサイトなどを偽装したサイトに利用者を誘導して、個人情報などを入力させる手口。
　利用者が信頼しているドメインにオープンリダイレクタ脆弱性があると、注意深い利用者でも個人情報を入力する可能性が高い。
　また、プログラムなどをダウンロードするサイトに脆弱性があると、マルウェアを配布される可能性がある。
 
　・攻撃手法と影響
　　1．ログイン画面に飛ぶ正規のURLに罠サイトへ誘導するパラメータを付けて、利用者にメールなどで閲覧するように仕向ける
  　　　http://example.jp/47/47-001.php?url=http://trap.example.com/47/47-900.php
　　2．アプリケーション側で正規の情報を入力してログインに成功するが、罠サイトに飛ばされる
　　3．罠サイトではログインエラーなどとして再度、ログイン情報を入力させる（ターゲットは間違えたかと思うだけ）
　　4．入力された情報を攻撃者は収集し、その後正規の画面にリダイレクトすることで気づくこともなく攻撃終了
  
・原因
　・リダイレクト先のURLを外部から指定できる
　・リダイレクト先のドメインのチェックがない
　これは両方が成立したときに脆弱性になるため、どちらか一方を対策するだけで脆弱性はなくせる。
　
　・オープンリダイレクタが差し支えないケース
　　・もともと外部のドメインに遷移する仕様であること
　　・利用者にとって外部ドメインに遷移することが自明であること
  　これはバナー広告などで外部サイトに遷移することが自明である場合は脆弱性にはならない。

・対策
　根本的対策は以下のいずれかを実施すること。
　1．リダイレクト先のURLを固定する
　　　リダイレクト先URLを外部から指定するのではなく固定のURLに遷移する。
   
　2．リダイレクト先のURLを直接指定せず番号指定にする
　　　やむを得ずリダイレクト先を可変にする場合はURLをそのまま指定するのではなく、「ページ番号」の形で指定する。
  　　ページ番号とURLの対応表は外部から見えないスクリプトソースやファイル、データベースなどで管理する。
　　　クッションページをはさむ。
    
　3．リダイレクト先のドメインをチェックする
　　　リダイレクト先のURLのチェックにより、任意のドメインへの遷移を防止する。
　　　チェックは漏れが多いため、1,2を推奨する。
  　　失敗例：　　　　　　　　　　　　　　　　　　　　　　　　　         すり抜ける例：
  　　if(mb_ereg('example\.jp', $url)){ // チェックOK}　        ➡　http://trap.example.com/example.jp.php
　　　if(mb_ereg('^/', $url)){ // チェックOK} 　　　　　         ➡　//trap.example.com/47/47-900.php
　　　if(mb_ereg('^http://example\.jp/', $url)){ // チェックOK} ➡　HTTPヘッダ・インジェクションを防げない
 　　 正しい対策：
　　　if(mb_ereg('\Ahttps?://example\.jp/[-_.!~*\'();\/?:@&=+\$, %#a-zA-Z0-9]*\z', $url)){ // チェックOK}


◎　HTTPヘッダ・インジェクション
・概要
　リダイレクトやクッキー発行など、外部からのパラメータを元にHTTPレスポンスヘッダを出力する際に発生する脆弱性。
　レスポンスヘッダを出力する際のパラメータ中に改行を挿入する攻撃によって、被害者のブラウザ上で以下のどちらか、もしくは両方が発生する。
　1．任意のレスポンスヘッダの追加
　2．レスポンスボディの偽造
 
　・影響
　　・任意のクッキーの生成
　　・任意のURLへのリダイレクト
　　・表示内容の改変
　　・任意のJavaScript実行によるXSSと同様の被害
  
  ・攻撃手法
  　1．パラメータに罠サイトのURLを入れておく（チェックを抜けるために最初に正当なLocationヘッダ情報を入れ込む）
   　　　例：http://example.jp/47-020.cgi?url=http://example.jp/%0D%0ALocation:+http://trap.example.com/47-900.php
    2．パラメータに改行(%0D%0A)があるため、元々入っていたLocationヘッダの情報が上書き（最後のLocationヘッダしか読まない）される
    3．罠サイトに入る
    このように改行により新たなHTTPレスポンスヘッダを追加する攻撃をHTTPヘッダ・インジェクション攻撃という。
    HTTPヘッダにSet-Cookieヘッダを加えることでセッションIDを固定することもできる（セッションフィクセーション）。
    また、PageIDを変更することで偽の画面に誘導することもできる。
    
    ・HTTPレスポンス分割攻撃（キャッシュ汚染）
    　・概要
    　　HTTPヘッダ・インジェクション攻撃により複数のHTTPレスポンスを作り出し、キャッシュサーバー（プロキシサーバー）に偽のコンテンツをキャッシュさせる攻撃。
  　　　HTTP/1.1では複数のリクエストをまとめて送信することができたため、HTTPリクエストをHTTPヘッダ・インジェクション攻撃の後に付け加えて
　　　　挿入することでキャッシュサーバーがこの偽のコンテンツを誤認してキャッシュする。
　　　・原因・対策
　　　　HTTPヘッダ・インジェクション攻撃と同様

・原因
　HTTPレスポンスヘッダはテキスト形式で1行に1つのヘッダを定義できる。つまり、ヘッダとヘッダは改行で区切られる。
　この性質を悪用し、リダイレクト先URLやクッキー値として設定されるパラメータ中に改行を挿入した場合、改行がそのままレスポンスとして出力されることが原因。

・対策
　1．外部からのパラメータをHTTPレスポンスヘッダとして出力しない
　　　HTTPレスポンスヘッダを用いる機能の代表はリダイレクトとクッキー生成だが、以下の方針に従うことで外部パラメータを直接ヘッダとして出力する機会は大幅に減少する。
　　　・リダイレクト先をURLとして直接指定するのではなく、固定にするか番号などで指定する
　　　・Webアプリケーション開発ツールの提供するセッション変数を使ってURLを受け渡す
  　　つまり、設計段階から外部パラメータをHTTPレスポンスヘッダとして出力しない検討をする。
    
　2．リダイレクトやクッキー生成を専用APIに任せ、ヘッダ生成するパラメータの改行文字をチェックする
　　　・リダイレクトやクッキー生成を専用APIに任せる
   　　　Webアプリケーション側の言語やライブラリの関数を使うことで予防できる。
 　　　　各言語の提供するHTTPレスポンスヘッダ出力機能
         言語　　　　　　クッキー生成　　　　　　　　　　　  リダイレクト　　　  　　　　　　   　レスポンスヘッダ出力
         PHP　　　　　　 setcookie / setrowcookie         なし（headerを利用）　　　　　　　   header
         Perl+CGI.pm    CGI::Cookie                      redirect                          header
         Java Servlet   HttpServletResponse#addCookie    HttpServletResponse#sendRedirect  HttpServletResponse#setHeader
         ASP.NET        Response.Cookies.Add             Response.Redirect                 Response.AppendHeader
     
     ・ヘッダ生成するパラメータの改行文字をチェックする
     　・URL中の改行はエラーとする
 　　　・クッキー値の改行はパーセントエンコードする
    　　ただし、ライブラリ側でクッキー値をパーセントエンコードしている場合はアプリケーション側でのパーセントエンコードは必要ない。
    　　PHPのsetcookie関数と、PerlのCGI::Cookieモジュールはパーセントエンコードがされてある。
    　　PHPのheader関数をラップして文字種のチェック機能付きのリダイレクト関数を定義した例：
    　　<?php 
          // リダイレクト関数を定義する
          function redirect($url){
            // URLとして不適切な文字があればエラーとして処理終了
            if(!mb_ereg("\\A[-_.!~*'();\\/?:@&=+\\$,%#a-zA-Z0-9] + \\z", $url)){
                die('Bad URL');
            }
            header('Location: ' . $url);
          }
          // 呼び出し例
            $url = isset($_GET['url']) ? $_GET['url'] : '';
            redirect($url);
        ?>
    

-----------------------------------------------------------------------------------------------------------

★　クッキー出力にまるわる脆弱性

　　クッキーにまるわる脆弱性を大別すると、以下になる。
  　1．クッキーを利用すべきでない目的で使っている
  　2．クッキーの出力方法に問題がある
  　クッキーはセッションIDの保管場所として利用すべきであり、データそのものをクッキーに保存してはいけない。
   
◎　クッキーの不適切な利用
　　Webアプリケーションでページをまたがる情報を保存するほうほうとしては、PHPやServletコンテナが提供するセッション管理機構が使われる。
　　セッション管理機構ではセッションIDのみをクッキーに保存、データ自体はWebサーバーのメモリやファイル、DBなどに保存する。
　　一方クッキーに保存すべきでないデータをクッキーに保存すると脆弱性が発生する可能性がある。
  
　　・クッキーに保存すべきでない情報
　　　クッキー値はアプリケーションの利用者によって書き換えが可能である。
 　　 書き換えられると困る情報の典型例は、ユーザーIDや権限情報で、クッキーに保存していたために権限外の操作や情報閲覧ができる場合がある。
  　　クッキーで実現できてセッション変数で実現できないのは、情報の寿命の制御と異なるサーバーとの情報共有の2点だけなので通常はセッション変数を使うべきである。
  　　また、セッション変数は漏洩のしにくさを以下の理由で制御可能である。
  　　・Webアプリケーションで機密性の高い情報を表示する場合にパスワードの再入力を求めることができる。
  　　・セッションに保存されている情報がセッションタイムアウトすれば表示できなくなる。
  　　クッキー自体に情報を保存している場合はこのような制御は不可能である。
    　一方でセッションやサーバーをまたがって情報を保存する必要性がある場合にはクッキーを使用する。
    　使用例としては、ログイン画面でのログイン状態を保持するなどの機能である。
    　この例でもクッキーに保存するのはトークンという乱数であり、パスワードなどのデータをクッキーに保存すべきではない。
    
  参考：パディングオラクル攻撃とMS10-070
  　　一部のWebアプリケーションフレームワークではセッション情報をサーバー側だけでなく、クライアント側のhiddenパラメータやクッキーに暗号化して保存する。
  　　代表例はASP.NETで、ページの状態（ビューステート）をhiddenパラメータに認証状態（フォーム認証チケット）をクッキーに保存する。
  　　しかし、T.DuongとJ.Rizzoの両氏がこれら暗号化された情報がパディングオラクル（暗号解読の手法の名前でオラクルとは無関係）という攻撃手法で解読されることを発表した。
　　　事態を重く見たマイクロソフト社はわずか10日で対策プログラムを開発し、定例外パッチ（MS10-070セキュリティパッチ）として公開した。

◎　クッキーのセキュア属性不備
・概要
　クッキーにはSecureという属性があり、これを指定したクッキーはHTTPSの場合のみブラウザからサーバーに送信される。
　アプリケーションがHTTPS通信を利用していても、セキュア属性のついていないクッキーは平文で送信される可能性があり、盗聴される場合がある。
 
　・攻撃手法と影響
　　1．罠サイトを見たターゲットにHTTPで指定したHTMLを返す
  　2．基本はHTTPS通信を使っていても443ポートに対するHTTPリクエスト（平文）を送信させる罠により、暗号化されていない状態でネットワーク上を流れる
　　3．HTTPリクエスト中のクッキーを盗聴することで、セッションハイジャックができる

・原因
　セキュア属性を付けていないことであるが、つけない主な原因は以下の2種類である。
　1．開発者がセキュア属性について知らない
　2．セキュア属性を付けるとアプリケーションが動かなくなる
 
　・クッキーにセキュア属性を付けられないアプリケーション
　　ショッピングサイトなどのWebアプリケーションはHTTPとHTTPSの両方を使っている。
　　カタログページから商品を選ぶ際にHTTP、決済する段階からHTTPSを利用する。
　　このような場合、セッションIDを保持するクッキーにセキュア属性を設定することは困難である。
　　仮にセッションIDのクッキーにセキュア属性をつけると、HTTPのページではセッションIDのクッキーが受け取れないため、
　　セッション管理機構がつかなくなるためである。
　　HTTP側のページでも、ショッピングバスケットの実現などにセッション管理機構は利用したいため、
　　HTTPSを利用するサイトの多くが、セッションIDのクッキーに対してセキュア属性を付けていないのが現状である。

・対策
　クッキーにセキュア属性を付けることが対策となる。
　
　・セッションIDのクッキーにセキュア属性をつける方法
　　PHPの場合：php.iniで設定
　　session.cookie_secure = On
　　ASP.NETの場合：web.configで設定
　　<configuration>
     <system.web>
        <httpcookies requireSSL = "true" />
     </system.web>
   </configuration
  
　・トークンを用いた対策
　　セッションIDを保持するクッキーにセキュア属性を付けられない場合はトークンを利用してセッションハイジャックを防ぐ。
　　トークンを保持するクッキーにセキュア属性をつけることでHTTPのページとHTTPSのページでセッションを共有しつつ、
　　仮にセッションIDを盗聴されてもHTTPSのページはセッションハイジャックを防げる。
　　PHPの場合：
　　<?php 
    // /dev/urandomによる擬似乱数生成器
    function getToken(){
        $s = file_get_contents('/dev/urandom', false, NULL, 0, 24);
        return base64_encode($s);
    }
       // ここまでで認証成功していると想定
       session_Start();
       session_regenerate_id(true); // セッションIDの再生成
       $token = getToken(); // トークンの生成
       // トークンクッキーはセキュア属性をつけて発行する
       setcookie('token', $token, 0, '', '', true, true);
       $_SESSION['token'] = $token;
   ?>
   HTTPSのページではトークンを確認する
   <?php
    session_start();
    // ユーザーIDの確認（省略）
    // トークンの確認
    $token = $_COOKIE['token'];
    if(! $token || $token != $_SESSION['token']){
        die('認証エラー。トークンが不正です');
    }
   ?>
   <body>トークンをチェックし、認証状態を確認しました</body>
   
   ・なぜトークンにより安全性が確保できるか
　　　1．トークンは認証成功時に一度だけサーバーから出力される
　　　2．トークンはHTTPSのページで生成される（サーバー→ブラウザ）
　　　3．トークンは確実に暗号化されてブラウザから送信される（ブラウザ→サーバー）
　　　4．HTTPSのページを閲覧するにはトークンが必須
   　　トークンがサーバーとブラウザの双方向で確実に暗号化されること、HTTPSのページを閲覧するには
     　第三者が知りえないトークンが必要であることから、安全性が確保されていることとなる。
      
　・セキュア属性以外の属性値に関する注意
　　セッションIDを保持するクッキーの属性
　　1．Domain属性
　　　　Domain属性を指定するのは複数のサーバーでクッキーを共有する場合で通常セッションIDを複数サーバー間で共有する意味はないため、デフォルト状態がもっとも安全な状態。　　
　　2．Path属性
　　　　ディレクトリ毎に異なるセッションIDを発行したい場合は設定が必要だが、通常はデフォルト状態（「path=/」）で問題ない。
　　3．Expires属性
　　　　設定すると、ブラウザ終了後も認証状態を維持できるが、通常は属性をつけずにブラウザ終了と同時にクッキーが削除される状態にする。
　　4．HttpOnly属性
　　　　この属性を付けるとクッキーはJavaScriptから参照できなくなる。セッションIDをJavaScriptから参照する必要はないため、設定するとよい。
    　　PHPの場合：php.iniで設定
      　session.cookie_httponly = 1
   
   
-----------------------------------------------------------------------------------------------------------

★　メール送信の問題

◎　メール送信の問題の概要

　・メールヘッダ・インジェクション脆弱性
　
　・hiddenパラメータによる宛先保持
　　無料で提供されるメール送信用フォームなどには、カスタマイズを簡単に行うことを目的にメールの送信先などをhiddenパラメータとして指定するものがある。
　　こういったフォームではhiddenパラメータの送信先アドレスを任意のアドレスに変更することで迷惑メールの送信に悪用される可能性がある。
　　送信先メールアドレスはhiddenパラメータに保持するのではなく、ソースコードにハードコーディングするか、サーバー上の安全な場所（ファイルやDBなど）に保持すべきである。
  
　・メールサーバーによる第三者中継
　　メールサーバー（Mail Transfer Agent;MTA)の設定に問題があると、第三者のメールを中継する場合がある。
　　このような設定のサーバーは迷惑メールなどの送信に悪用される可能性がある。
　　1．攻撃者は第三者中継をしているサーバーを探して、このサーバー経由でターゲットにメールを送る。
　　2．ターゲットは攻撃者のメールを迷惑メール設定にしているが、このサーバーを通すことで受信するようになる。
　　最近のメールサーバーソフト（MTA)はデフォルト状態で第三者中継を許さない設定になっており、安全になっている。
  
◎　メールヘッダ・インジェクション脆弱性
・概要
　宛先や件名などのメールヘッダを外部から指定する際に改行文字を使ってメールヘッダや本文を追加変更する手法。
　影響は3種類ある。
　1．件名や送信元、本文を改変される
　2．迷惑メールの送信に悪用される
　3．ウイルスメールの送信に悪用される
 
　・攻撃手法と影響
　　お問合せフォームからメールアドレスと本文を送信するとリクエストを受けてメールを受け取る。
　　メールの送信にメール送信関数のmb_send_mail()を使う。
　　mb_send_mail() 
  　　第一引数：宛先メールアドレス　第二引数：件名　第三引数：本文　第四引数：追加のメールヘッダ
    mb_send_mail("wasbook@example.jp", "お問合せがありました", "以下の問い合わせがありましたので対応お願いします\n\n" . $body, "From:" . $from);
    
    1．攻撃1：宛先の追加
    　　1．攻撃者がメール欄に改行を入力できるようにメールアドレスの入力欄をtextarea要素に変更したフォームを用意する。
      　2．Bccで攻撃者にもメールを送信できるように設定することで管理者に気づかれることなくメールを回収できる。
       　この方法ではCcやTo、Reply-Toなどを追加できる。
    
    2．攻撃2：本文の改竄
    　　攻撃1と同様にメールアドレス欄に空行と本文に追加したい文章を書き込むことで本文の改竄ができる。
      　MIMEタイプによっては別の攻撃にもなる。
      　例えば、添付ファイルを送りたい場合はmultipart/mixedという形式にするとファイルを送ることができる。  

・原因
　メールのメッセージ形式をまずは理解する。
　・メールメッセージの形式
 　ヘッダ　　To: wasbook@example.jp
            Subject: =?ISO-2022-JP?B?GyRCTGQkJDlnJG8kOyQsJCIbKEI=?=
                     =?ISO-2022-JP?B?GyRCJGokXiQ3JD8bKEI?=
            From: alice@example.jp
            Content-Type: text/plain; charset=ISO-2022-JP
   空行
   ボディ　　以下の問い合わせがありましたので対応お願いします
   　　　　　発注番号4309の納期を回答ください
        
  このようにメール送信ライブラリの多くはメールメッセージのヘッダから送信先のアドレスを抽出する。
  ヘッダの各フィールドは改行で区切られているため、外部から指定するパラメータに改行を挿入すれば、新たなヘッダを追加できる。
  改行に特別な意味があるのにアプリケーション側でチェックしていない場合は、攻撃の可能性がある。

・対策
　メール送信にsendmailコマンドではなく、専用のライブラリを使用する。
　更に、以下のいずれかを実施する。
　1．外部からのパラメータをメールヘッダに含ませないようにする
　2．外部からのパラメータには改行を含まないようにメール送信時にチェックする
 
　・メール送信には専用のAPIやライブラリを使用する
　　ライブラリを用いるメリット3点。
　　1．sendmailコマンドによるメール送信はメッセージ組み立てをアプリケーションがすべて責任を持たなければならず、脆弱性が入りやすい
　　2．sendmailコマンド呼び出しの際にOSコマンド・インジェクション脆弱性が混入しやすい
　　3．メールヘッダ・インジェクション脆弱性は本来は専用ライブラリで対策されるべき
  
　・外部からのパラメータをメールヘッダに含ませないようにする
　　例えば、Fromヘッダは固定にして、利用者のメールアドレスなどは本文に表示するようにする。
  
  ・外部からのパラメータには改行を含まないようにメール送信時にチェックする
　　メール送信関数を直接呼ぶのではなく、ラッパー関数を作成してラッパー関数側で改行文字をチェックする。
  　ラッパー関数　➡　関数や機能を使いやすくするための簡単な関数のこと。
   
　・保険的対策
　　・メールアドレスのチェック
　　・件名のチェック　➡　制御文字以外にマッチする正規表現でチェックできる。例：if(preg_match('/\A[[:^cntrl:]]{1, 60}\z/u', $subject) == 0 )
　　

-----------------------------------------------------------------------------------------------------------

★　ファイルアクセスにまつわる問題

◎　ディレクトリ・トラバーサル脆弱性
・概要
　外部からのパラメータの形でサーバー上のファイル名を指定できるWebアプリケーションではファイル名に対するチェックが不十分であると、
　アプリケーションの意図しないファイルに対して閲覧や改竄、削除ができる場合がある。
　ディレクトリ・トラバーサル脆弱性の影響
　1．Webサーバー内のファイル閲覧　➡　重要情報の漏洩
　2．Webサーバー内のファイルの改竄、削除　➡　Webコンテンツ改竄によるデマ、誹謗中傷の書き込み
 　　　　　　　　　　　　　　　　　　　　　　 マルウェアのサイトに誘導する仕組みの書き込み
                        　　　　　　　　　　スクリプトファイルや設定ファイル削除によるサーバー機能停止
                                          スクリプトファイル改竄による任意のサーバースクリプト実行

　・攻撃手法と影響
　　1．パラメータに別ファイルへの相対パスを入れることで別ファイルにアクセスされる。
　　アプリケーションによっては、書き込みや削除ができる可能性があり、データの改ざんなどの影響がある。
　　更に、PHPなどのスクリプトファイルに書き込みができると、そのスクリプトをWebサーバー上で実行できるため、
　　外部から不正プログラムをダウンロードされたり、システムに対する不正操作が可能になる。
　　

・原因
　1．ファイル名を外部から指定できる
　2．ファイル名として、絶対パスや相対パスの形で異なるディレクトリを指定できる
　3．組み立てたファイル名に対するアクセスの可否をチェックしていない

・対策
　原因のどれかを対策できればいいため、以下のいずれかを実施する。
　1．外部からファイル名を指定できる仕様を避ける
 　　・ファイル名を固定にする
　　 ・ファイル名をセッション変数に保存する
　　 ・ファイル名を直接していするのはなく番号などで間接的に指定する
   
　2．ファイル名にディレクトリ名が含まれないようにする
　　　まず、ディレクトリ名（../）を含まないようにする。
　　　PHPの場合：basename関数　➡　ディレクトリつきのファイル名を受け取り、最後の名前の部分を返す。
   　　　　　　　$tmpl = basename('../../../../etc/hosts');　➡　hostsを返す

　3．ファイル名を英数字に限定する
　　　攻撃に用いる記号文字が使えないように英数字に限定する。
   　　実装例：
     　if(! preg_match('/\A[a-z0-9]+\z/ui', $tmpl){}

◎　意図しないファイル公開
・概要
　外部から閲覧されるとよくないファイルをWebサーバーの公開ディレクトリに配置している場合、ファイルに対するURLが分かると秘密ファイルの閲覧が可能になる。
　重要情報の漏洩につながるため、公開ディレクトリに非公開ファイルを置かないことである。
 
　・攻撃手法と影響　
　　1．URLにディレクトリ名を指定してファイル一覧を表示する（この機能をディレクトリ・リスティングという）。
　　2．表示されたファイルにアクセスする。

・原因
　非公開ファイルを公開ディレクトリに置いたことが原因。
　公開ディレクトリに置いたファイルを外部から閲覧できる条件は次である。
　1．ファイルが公開ディレクトリに置かれている
　2．ファイルに対するURLを知る手段がある
　3．ファイルに対するアクセス制限がかかっていない
 
　・ファイルに対するURLを知る手段
　　1．ディレクトリ・リスティングが有効
　　2．ファイル名が日付やユーザー名、連番など類推可能
　　3．user.dat, data.txtなどのありがちな名前
　　4．エラーメッセージやほかの脆弱性によりファイルが分かる
　　5．外部サイトからリンクされるなどして検索エンジンに登録される

・対策
　1．アプリケーションの設計時にファイルの安全な格納場所を決める
　2．レンタルサーバーを契約する場合は非公開ディレクトリが利用できることを確認する
 
　・保険的対策
　　ディレクトリ・リスティングを無効にする。
　　Apacheの場合：httpd.confに設定
　　<Directory パス指定>
        Options -Indexes その他のオプション
        その他の設定
    </Directory>
    レンタルサーバーなどの場合：.htaccessに設定
    Options -Indexes
    
　参考：Apacheで特定のファイルを隠す方法
　　　　既存Webサイトで簡単にファイル移動ができない場合がある。
　　　　その場合、ファイルの外部からの閲覧を禁止する設定により対処できる。
　　　　Apacheの場合：htaccessに設定
   　　 <Files "*.txt">  // txtファイルへのアクセスを禁止
            deny from all
        </Files>
    
    
-----------------------------------------------------------------------------------------------------------

★　OSコマンド呼び出しの際に発生する脆弱性

◎　OSコマンド・インジェクション脆弱性
・概要
　Webアプリケーションの開発に用いる言語の多くはシェル経由でOSコマンドを呼び出す機能を提供しており、
　シェルを呼び出せる機能の使い方に問題があると意図しないOSコマンドが実行可能となる。
　攻撃シナリオは以下である。
　1．攻撃用ツールを外部からダウンロードする
　2．ダウンロードしたツールに実行権限を与える
　3．OSの脆弱性を内部から攻撃して管理者権限を得る（Local Exploit）
　4．Webサーバーは攻撃者の思いのままになる
　悪用の例
　・Webサーバー内のファイルの閲覧・改竄・削除
　・外部へのメール送信
　・別のサーバーへの攻撃（踏み台と呼ばれる）
 
　・攻撃手法と影響
　　1．sendmailコマンドを呼び出すメール送信の例
　　　問い合わせフォームで「メールアドレス」と「問い合わせ内容」を送信すると、そのメールアドレス宛に受付のメールを送信する。
　　　1．メールアドレス欄にOSコマンド・インジェクション攻撃用スクリプトを入力する
   　　　bob@example.jp;cat /etc/passwd　
　　　2．送信ボタンを押すと/etc/passwdの内容が表示される
   　 この例では表示だけだが、Webアプリケーションが稼働するユーザー権限で実行できるコマンドはすべて悪用可能となる。
　　　具体的には、ファイルの削除、変更、外部からのファイルダウンロード、ダウンロードした不正ツールの悪用などがあげられる。
　　　また、内部からの攻撃による権限昇格で管理者権限を得ることもできる。
   
   2．オプションを追加指定することによる攻撃
   　アプリケーションが呼び出すOSコマンドによってはオプションの追加により攻撃に悪用される場合がある。
   　Unixのfindコマンドは条件を指定してファイルを探すコマンドだが、-execオプションにより、検索したファイル名に対してコマンドを
   　実行できるため、OSコマンドのオプションを追加指定するだけで想定外のOSコマンドを実行される危険性がある。

・原因

・対策

-----------------------------------------------------------------------------------------------------------

DNSリバインディング

-----------------------------------------------------------------------------------------------------------

◎　ヌルバイト攻撃

・概要
　ブラウザ上でJavaScriptが実行されて、XSS攻撃をされる。
 　例えば、入力値をチェックするフォームでヌルバイトが正しく処理されない場合、
  　正常値%00<script>悪い処理</script>
   と入れられたら、%00まではチェックして正常値を返し、その後ろがチェックされずに実行されてしまうということが発生する。

・原因
　バイナリセーフな関数を使用していない。
　バイナリセーフ…入力値がどんなバイト列であっても正しく扱えること。特にヌルバイトが現れても正しく処理できる
　ヌルバイト…値ゼロのバイト（PHPでは\0と表記）。特別なのはC言語などではヌルバイトを文字列の終端とみなす取り決めがあるため。
 
・対策




