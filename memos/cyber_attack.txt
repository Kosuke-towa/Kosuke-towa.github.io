
サイバー攻撃について

長谷川陽介さんの「教科書に載らないWebアプリケーションセキュリティ」　https://atmarkit.itmedia.co.jp/fcoding/index/webapp.html

------------------------------------------------------------------


◎　XSS（クロスサイトスクリプティング）

・概要
攻撃者はインターネット掲示板などの動的なWebサイトにある入力フォームにワナ（脆弱性のあるサイトへ誘導するスクリプトを含んだリンク）を設置する。
リンクをクリックしてこのようなサイトに誘導されると、ユーザーのブラウザ上で不正なスクリプトが実行され、
入力した情報やCookieなどが攻撃者へ漏えい、マルウェアへの感染、なりすましなどの被害が発生する。

・原因
入力値が制限されていなかったり、入力したスクリプトをそのまま実行できる状態にあり、攻撃者が容易に不正なスクリプトを入力できてしまうことがあげられる。

・種類
　1．Reflected XSS（反射型XSS）
　　　攻撃者は偽メールや偽サイトに不正なスクリプトを含んだリンクを用意し、脆弱性のあるWebサイトに誘導する（リクエストさせる）ことで
　　　ユーザーのブラウザで不正なスクリプトを実行させ、情報の搾取やマルウェアのダウンロードを行う。

　2．Stored/Persistent XSS（格納型/蓄積型/持続型XSS）
　　　攻撃者はあらかじめWebアプリケーションに直接スクリプトを格納する。
　　　該当のページをユーザーが閲覧するたびに、不正なスクリプトが実行される。
　　　該当ページにアクセスするだけであるため、Reflected XSSと比べると
　　　ワナを仕掛けたWebサイトを準備したり、スクリプトを含んだリンクをメール送信したりしなくても攻撃が成立する点では効率的である。
    　WebメールやSNSなどが典型的な攻撃ターゲット。
      メリット：罠サイトに利用者を誘導する手間がかからないこと
      　　　　　注意深い利用者でも被害にあう可能性が高いこと

　3．DOM Based XSS
　　　Webブラウザで動作するJavaScript上のコードの脆弱性を悪用した攻撃で、サーバー側で攻撃用スクリプトが実行されるのではなく、
　　　クライアントのWebブラウザ上で不正なスクリプトが実行される。
　　　また、DOM Based XSSは静的なHTMLにおいてもJavaScriptが利用されていれば攻撃対象となる。
   　 HTML上には攻撃者が注入したJavaScriptが現れない攻撃。
      textメソッドを使うことで自動的にエスケープされて要素に追加される。
      実装例：
      <body>
      <script src="jquery-1.4.4.min.js"></script>
      こんにちは<span id="name"></span>さん
      <script type="text/javascript">
      if(document.URL.match(/name\=([^&]*/)) {
        var name = unescape(RegExp.$1);
        $('#name').text(name);
      }
      </script>
      </body>

・被害
　1．セッションハイジャック
　2．個人情報の流出
　3．Webページの改竄

・対策
　1．サニタイジング（エスケープ）処理をする
 　　・要素内容については「<」と「&」
   　・属性値についてはダブルクォートで囲い、「<」と「"」と「&」　をそれぞれエスケープする
　　  ブラウザで「<」という文字を表示させる場合は、文字参照により「&lt;」と記述（エスケープ）する必要がある。
     これを「<」のままHTMLを生成すると、ブラウザは「<」をタグの開始と解釈する。これを悪用したのがXSS攻撃。
　　　「<」や「””」といった区切りやタグなどの意味を持つ文字を意味を持たない文字列に置き換え無害化する行為である、
　　　サニタイジングを行うことでスクリプトが意図せずに挙動することを防ぐことができる。
   　　PHPではhtmlspecialchars関数で対策できる。
     　string htmlspecialchars(string $string, int $quote_style, string $charset)
       第1引数…変換対象の文字列　第2引数…引用符の変換方法　第3引数…文字エンコーディング
       
       引用符の変換
       変換前　　|　変換後　　|　ENT_NOQUOTES　|　ENT_COMPACT　|　ENT_QUOTES　|
       　 <         &lt;           〇　　　　　　　　〇　　　　　　    〇
        　>　　　　　&gt;           〇      　  　   〇               〇
          &         &amp;          〇              〇               〇
          "        &quot;          ×               〇               〇
          '        &#39;           ×               ×                〇
          
        ➡　要素内容　➡　$quote_styleはどれでもよい
        　　属性値　　➡　ダブルクォーテーションで囲み、$quote_styleはENT_COMPACT、もしくはENT_QUOTES

　2．バリデーション処理（入力値の制限）
　　　例えば、パスワード入力欄に「全角英数字の6文字」、電話番号入力欄に「数字のみ」などの制限を入れることで不正なスクリプトを入力させない。
　　　JavaScriptを使い、ブラウザ側で入力値の制限を行ってしまうと、ユーザー側がJavaScriptをオフにして不正なスクリプトを入力ができるため、必ずサーバー側で制限を実施する。
   
　3．WAFを設置する
　　　WAF（Web Application Firewall）はWebアプリケーションを対象とした攻撃を検知・防御するセキュリティ製品。
　　　自社においてオープンソースのシステムを利用していたり、CMSやフレームワークを使ってWebサイトを構築していたりする場合、
　　　全ての脆弱性修正に対応するのは限界があるため、WAFの導入は必要不可欠である。

　4．出力時はhttpやhttpsから始まるURLのみ許可する
　　　URLに「JavaScriptスキーム」や「dataスキーム」などが含まれている場合でも、クロスサイトスクリプティングのリスクが生じる。
　　　入力するリンク先のURLはhttpやhttpsから始まるもののみを許可する設定にすることで想定外の処理がされるリスクを防げる。
   
  5．クッキーにHttpOnly属性を付与する　
  　　この属性はJavaScriptからのクッキーの読み出しを禁止するというもの。
    　セッションIDの盗み出しには効果があるが、その他の攻撃には有効ではない。
      これはphp.iniに「session.cookie_httponly = On　」と追加することでできる。

　6．TRACEメソッドの無効化
 　　　クロスサイトトレージング（XST）という攻撃の対策。
    　　XST…JavaScriptによりHTTPのTRACEメソッドを送信することでクッキー値やBasic認証のパスワードを盗む方法。
      　XSS攻撃を完全に解消できれば、問題はない。
        最近のブラウザではXST対策がなされている。
        TRACEメソッドの無効化はhttpd.confに「TraceEnable　Off」と追加する。
        
  7．URLを生成する際の対策
  　　URLをプログラムで作成する場合はhttpスキームとhttpsスキームのみを許可するようにチェックする必要がある。
    　具体的にはURLとしては以下のいずれかのみを許容するようにチェックする。
     　・http:　または　https:　で始まる絶対URL
       ・スラッシュ「/」で始まる相対URL
       チェックする関数
       function check_url($url){
            if(preg_match('/\Ahttp:/', $url) ||
               preg_match('/\Ahttps:/', $url) ||
               preg_match('#\A/#', $url)) {
                return true;
            }else{
                return false;
            }
        }
        
  8．リンク先ドメインのチェック
  　　リンク先として任意のドメインのURLを指定できる場合、利用者が気付かない内に罠のサイトに誘導され、
    　フィッシングの手法で個人情報等を入力させられる可能性がある。
     　対策
       ・リンク先を検証してURLが外部ドメインである場合はエラーにする
       ・外部ドメインへのリンクであることを利用者に注意喚起するためのクッションページを表示する
       
  9．イベントハンドラのXSSはJSをエスケープする必要がある
  　　JSを動的生成するケースでは入力パラメータ中のシングルクォート「'」がデータとしての文字「'」ではなく、
    　JSの文字列の終端に使われてしまうことが原因で脆弱性が発生する。
       対策
     　・データをJavaScript文字列リテラルとしてエスケープする
       ・この結果をHTMLエスケープする
       
       JavaScriptの文字列リテラルとしてエスケープすべき文字
       　文字　　　|　エスケープ後
        　\           \\
          '           \'
          "           \"
         改行         \n
         
         そのため入力に「<>'"\」が与えられた場合は以下の様にエスケープする必要がある。
         　元入力　<>'"\　➡　JavaScriptエスケープ後　<>\'\"\\　➡　HTMLエスケープ後　&lt;&gt;\&#39;\&quot;\\

　10．script要素のXSS
 　　　入力中に「</script>」が含まれている場合、そこでJavaScriptのソースの終端となり、
    　　再度「<script>alert(document.cookie)//」などと入れることでXSS攻撃が可能である。
      
  11．JavaScriptの動的パラメータ生成時の対策
  　　1．Unicodeエスケープによる対策
    　　英数字以外をすべてエスケープする手法で、UnicodeコードポイントU+XXXXの文字を\uXXXXという形でエスケープする機能を利用する。
      　Unicodeエスケープする関数escape_js_stringは文字エンコーディングがUTF-8であることが前提だが、
        英数字に加えてマイナス記号「-」とピリオド「.」をエスケープしない仕様になっている。
        実装例：
        <?php 
         // 文字列を全て\uXXXX形式に変換する
         function unicode_escape($matches){
            $u16 = mb_convert_encoding($matches[0], 'UTF-16');
            return preg_replace('/[0-9a-f]{4}/', '\u$0', bin2hex($u16));
         }
         // 英数字とマイナス、ピリオド以外を\uXXXX形式でエスケープする
         function escape_js_string($s){
            return preg_replace_callback('/[^-\.0-9a-zA-Z]+/u', 'unicode_escape', $s);
         }
         ?>
         
         スクリプトの説明
         ・unicode_escape関数は入力文字列をすべて\uXXXXというUNICODE形式でエスケープする
         ・mb_convert_encodingで入力をUTF-16でエンコーディングする
         ・bin2hexで16進数文字列に変換する
         ・正規表現により4バイト毎に「\u」を挿入する
         ・escape_js_string関数は入力文字列の中から、英数字以外を\uXXXX形式でエスケープする
         ・preg_replace_callback関数により英数字以外からなる文字列をunicode_escape関数に引き渡す
         
      2．script要素の外部でパラメータを定義して、JavaScriptから参照する方法
      　　hiddenパラメータを利用する。
        　実装例：
          <input type="hidden" id="familyname" value="<?php echo htmlspecialchars($familyname, ENT_COMPACT, 'UTF-8'); ?>">
          ...
          <script type="text/javascript">
          var familyname = document.getElementById('familyname').value;
          //..
          
          2行目で値を設定する際に属性値に対するエスケープ原則に従い、htmlspecialchars関数でエスケープした値をダブルクォートで囲んでいる。
          そのinputの値をgetElementByIdメソッドにより参照している。

◎　CSRF（クロスサイトリクエストフォージュリ）

・概要
　「重要な処理」の脆弱性があるとクロスサイトリクエストフォージェリが生じる可能性がある。
 　重要な処理…クレジットカードでの決済、利用者の口座からの送金、メール送信、パスワードやメールアドレスの変更
  重要な処理の受付に関しては、利用者の意図したリクエストであることを確認する必要があるが、
  この確認処理が抜けていると、罠のサイトなどを閲覧しただけで利用者のブラウザから勝手に重要な処理を実行させられることがある。
  WebアプリケーションにCSRF脆弱性がある場合の影響
  ・利用者のアカウントによる物品の購入
  ・利用者の退会処理
  ・利用者のアカウントによる掲示板への書き込み
  ・利用者のパスワードやメールアドレスの変更
  

・原因

・対策
　設計段階から対策を盛り込む必要がある。

・CSRFとXSSの比較
攻撃に至るシナリオが似ており、攻撃の影響が一部重なるため、混同しやすいが、別物である。
シナリオを以下に示し、違いを見る。
1．被害者が攻撃者の罠サイトを閲覧
2．仕掛けのあるHTMLがブラウザに返される
3．攻撃用リクエストが正規のサイトに送られる
4．仕掛けを含むレスポンスが正規のサイトからブラウザに返される
CSRFは3.のリクエストに対するサーバー側の処理を悪用するもの。
XSSは3.のリクエストに含まれるスクリプトはオウム返しに4.のレスポンスとして返され、
それがブラウザ上で実行されることで攻撃が起こる。ブラウザ上でできることは何でもできるため、
JavaScriptを使ってサーバー側の機能を悪用することもできる。


◎　SQLインジェクション

・概要
　　SQLの呼び出し方に不備がある場合に発生する脆弱性。
 　・データベース内の全ての情報が外部から盗まれる
   ・データベースの内容が書き換えられる
   ・認証を回避される（IDとPASSを使わずにログインされる）
   ・その他、データベースサーバー上のファイルの読み出し、書き込み、プログラムの実行など

・攻撃の種類
　1．UNION SELECTを用いた情報漏洩
  2．SQLインジェクションによる認証回避
  3．SQLインジェクション攻撃によるデータ改ざん
  4．その他の攻撃
  　　・OSコマンドの実行
    　・ファイルの読み出し、書き出し
    　・HTTPリクエストのより他のサーバーを攻撃

・原因
　リテラルの扱いに原因がある。
　リテラルとはSQL中で決まった値を示すもので、文字列リテラルと数値リテラルが頻繁に利用される。
　SQLの標準規格では文字列リテラルをシングルクォートで囲み、文字列リテラル中にシングルクォートを含む場合は
　シングルクォートを重ねる決まりである。
　SQL脆弱性のあるプログラムはこのシングルクォートを重ねる処理が抜けているため、
　最初のシングルクォートで文字列リテラルが終了され、その後に悪意のあるSQLを注入されて攻撃が発生する。
　数値リテラルも同様に数字以外が入るとリテラルが終了する。
　例えば「;」が入った後に悪意のあるSQLで攻撃される。

・対策
　1．プレースホルダによりSQL文を組み立てる
　2．アプリケーション側でSQL文を組み立てる際に、リテラルを正しく構成するなど、SQLが変更されないようにする
 　2は完全な対応が難しいため、1の方法が良い。
  
  プレースホルダ
  ・2種類のプレースホルダ
  　1．静的プレースホルダ
   　　値のバインドをデータベースエンジン側で行う。
     　プレースホルダのついたSQL文はそのままデータベースエンジンに送られ、コンパイルなどの実行準備が行われ、SQL文が確定する。
　　　　バインド値がデータベースエンジンに送られ、エンジン側で値を当てはめた後にSQL文が実行される。

　　2．動的プレースホルダ
  　　　SQLを呼び出すアプリケーション側のライブラリ内でパラメータをバインドしてデータベースエンジンに送る。
　　　　バインドにあたりリテラルは適切に構成されるため、処理系にバグが無ければSQLインジェクションは発生しない。
    
    どちらかといえば静的プレースホルダが優れているため、そちらを使うべき。
    
 ・検索条件が動的に変わる場合のプレースホルダ対策
 // 基本となるSQL
 $sql = 'SELECT id, title, author, publisher, date, price FROM books';
 if($title !== ''){  // 検索titleの追加（LIKE)
     $conditions[] = "title LIKE ? ESCAPE '#'";
     $ph_type[]    = 'text';
     $ph_value[]   = escape_wildcard($title);
 }
 if($price !== ''){  // 検索条件priceの追加（大小比較）
     $conditions[] = "price <= ?";
     $ph_type[]    = 'integer';
     $ph_value[]   = $price;
 }
 if(count($conditions) > 0){  // WHERE句がある場合
     $sql .= ' WHERE ' . implode(' AND ', $conditions);
 }
 $smt = $mdb2 -> prepare($sql, $ph_type);  // SQL文の準備
 $rs  = $stmt -> execute($ph_value);  // バインド・問い合わせ実行
 

・ ORDER BY 句
　ORDER　BY 句の後もセミコロンで第二SQLを実行できる。
  対策として　ソート列名の妥当性確認を行う方法がある。
  例：
  $sort_columns = array('id', 'author', 'title', 'price');
  $sort_key = $_GET['sort'];
  if(array_search($sort_key, $sort_columns) !== false){
     $sql .= ' ORDER BY ' . $sort_key;
  }
  
  
・保険的対策
　1．詳細なエラーメッセージの抑止
  2．入力値の妥当性検証
  3．データベースの権限設定
  

    
・参考
　a.ワイルドカードのエスケープ
 　%などのワイルドカードを検索したい文字列として加えるにはエスケープする必要がある。
 　例：「#」を用いてエスケープする
  　WHERE name LIKE '%#%%' ESCAPE '#'
   「#%」で%を意味する
   関数例：
   function escape_wildcard($s){
        return mb_ereg_replace('([_%#])', '#\1', $s);
   }
   
   mb_ereg_replace()
   第一引数に変換するターゲットの正規表現パターン
   第二引数に変換後の文字列
   第三引数に対象文字列
   第四引数にオプション
        　i …大文字・小文字が 区別されなくなる
　        x …空白を無視
　        m …マルチラインモード。改行も 正規表現"." に含まれる。
　        p …POSIX モード。改行も通常文字とみなされる
　        e …文字列引数 $replacement がPHPの式として評価される
         

  b.PHP+PDO+MySQLの安全な接続方法
  　PDOはデータベース接続時に文字コードを指定する方法が用意されていないため、
    MySQLの設定ファイル名を指定する方法で文字コードを指定する。
    例：
    $dbh = new PDO('mysql:host=localhost;dbname=wasbook', 'username', 'password', 
                    array(
                        PDO::MYSQL_ATTR_READ_DEFAULT_FILE => '/etc/mysql/my.cnf',
                        PDO::MYSQL_ATTR_READ_DEFAULT_GROUP => 'client',
                        PDO::ATTR_EMULATE_PREPARES => false,
                    ));
     更に/etc/mysql/my.cnf（MySQLの設定ファイル）に次の設定を追加する。
      [client]
      default-character-set=utf8



セッションフィクセーション
ディレクトリトラバーサル
OSコマンドインジェクション
DNSリバインディング
オープンリダイレクタ



◎　ヌルバイト攻撃

・概要
　ブラウザ上でJavaScriptが実行されて、XSS攻撃をされる。
 　例えば、入力値をチェックするフォームでヌルバイトが正しく処理されない場合、
  　正常値%00<script>悪い処理</script>
   と入れられたら、%00まではチェックして正常値を返し、その後ろがチェックされずに実行されてしまうということが発生する。

・原因
　バイナリセーフな関数を使用していない。
　バイナリセーフ…入力値がどんなバイト列であっても正しく扱えること。特にヌルバイトが現れても正しく処理できる
　ヌルバイト…値ゼロのバイト（PHPでは\0と表記）。特別なのはC言語などではヌルバイトを文字列の終端とみなす取り決めがあるため。
 
・対策




